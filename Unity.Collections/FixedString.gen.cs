

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     TextTransform Samples/Packages/com.unity.collections/Unity.Collections/FixedString.tt
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using Unity.Collections.LowLevel.Unsafe;
using UnityEngine.Internal;
#if UNITY_PROPERTIES_EXISTS
using Unity.Properties;
#endif

namespace Unity.Collections
{

    [StructLayout(LayoutKind.Explicit, Size=16)]
    internal struct FixedBytes16
    {
      [FieldOffset(0)] internal byte byte0000;
      [FieldOffset(1)] internal byte byte0001;
      [FieldOffset(2)] internal byte byte0002;
      [FieldOffset(3)] internal byte byte0003;
      [FieldOffset(4)] internal byte byte0004;
      [FieldOffset(5)] internal byte byte0005;
      [FieldOffset(6)] internal byte byte0006;
      [FieldOffset(7)] internal byte byte0007;
      [FieldOffset(8)] internal byte byte0008;
      [FieldOffset(9)] internal byte byte0009;
      [FieldOffset(10)] internal byte byte0010;
      [FieldOffset(11)] internal byte byte0011;
      [FieldOffset(12)] internal byte byte0012;
      [FieldOffset(13)] internal byte byte0013;
      [FieldOffset(14)] internal byte byte0014;
      [FieldOffset(15)] internal byte byte0015;
    }


    [StructLayout(LayoutKind.Explicit, Size=30)]
    internal struct FixedBytes30
    {
        [FieldOffset(0)] internal FixedBytes16 offset0000;
        [FieldOffset(16)] internal byte byte0016;
        [FieldOffset(17)] internal byte byte0017;
        [FieldOffset(18)] internal byte byte0018;
        [FieldOffset(19)] internal byte byte0019;
        [FieldOffset(20)] internal byte byte0020;
        [FieldOffset(21)] internal byte byte0021;
        [FieldOffset(22)] internal byte byte0022;
        [FieldOffset(23)] internal byte byte0023;
        [FieldOffset(24)] internal byte byte0024;
        [FieldOffset(25)] internal byte byte0025;
        [FieldOffset(26)] internal byte byte0026;
        [FieldOffset(27)] internal byte byte0027;
        [FieldOffset(28)] internal byte byte0028;
        [FieldOffset(29)] internal byte byte0029;
    }

    /// <summary>
    /// An unmanaged string in UTF-8 format that contains its own fixed-size buffer of the given size in bytes.
    /// The string is NOT guaranteed to be null-terminated, though in many cases it may be by accident.
    /// No memory is ever allocated, and no attempt is made to share memory when strings are copied.
    /// Since this structure is not generic and needs no disposing, it can exist inside ECS components,
    /// can be put in a FixedArray, FixedList or FixedHashMap, and can be a data member of unmanaged structs
    /// that are allocated from the unmanaged heap. This string is entirely compatible with Burst compilation.
    ///
    /// The binary layout of this string is guaranteed, for now and all time, to be two bytes of little-endian length,
    /// followed by a contiguous array of bytes with that length, with no padding in between. This is intentionally
    /// identical to FixedList of byte, which is guaranteed to always have the same memory layout.
    ///
    /// Those who need more than 65,535 contiguous items should allocate from the heap, as storing that many things
    /// contiguously in a C# struct is likely to result in much wasted time, as the compiler copies the struct often.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Size=32)]
    public partial struct FixedString32
        : INativeList<byte>
        , IUTF8Bytes
        , IComparable<String>
        , IEquatable<String>
        , IComparable<FixedString32>
        , IEquatable<FixedString32>
        , IComparable<FixedString64>
        , IEquatable<FixedString64>
        , IComparable<FixedString128>
        , IEquatable<FixedString128>
        , IComparable<FixedString512>
        , IEquatable<FixedString512>
        , IComparable<FixedString4096>
        , IEquatable<FixedString4096>
    {
        internal const ushort utf8MaxLengthInBytes = 29;

        internal ushort utf8LengthInBytes;
        internal FixedBytes30 bytes;

        /// <summary>
        /// Returns the maximum number of utf8 bytes that can be stored in this type.
        /// </summary>
        public static int UTF8MaxLengthInBytes => utf8MaxLengthInBytes;

        /// <summary>
        /// A property in order to display the value in Unity.Properties generated UI.
        /// </summary>
        [CreateProperty]
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public string Value => ToString();

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe byte* GetUnsafePtr()
        {
            return (byte*) UnsafeUtility.AddressOf(ref bytes);
        }

        //
        // INativeList<byte> methods
        //

        /// <summary>
        /// The current length of the UTF-8 encoded string, in bytes.
        /// The string is guaranteed to he null-terminated.  The length value
        /// does not include the null terminating byte.
        /// </summary>
        public int Length
        {
            get
            {
                return utf8LengthInBytes;
            }
            set
            {
                CheckLengthInRange(value);
                utf8LengthInBytes = (ushort)value;
                unsafe
                {
                    GetUnsafePtr()[utf8LengthInBytes] = 0;
                }
            }
        }

        /// <summary>
        /// <undoc />
        /// </summary>
        [Obsolete("UTF8LengthInBytes has been renamed to just Length. (RemovedAfter 2020-08-01) (UnityUpgradable) -> Length", true)]
        public int UTF8LengthInBytes => Length;

        /// <summary>
        /// The maximum length of the UTF-8 encopded string, in bytes.
        /// Due to the UTF-8 encoding, each Unicode code point requires between 1 and 4 bytes to encode.
        /// The null terminating byte is not included in the capacity.  The FixedString always
        /// has space for a null terminating byte.
        /// </summary>
        public int Capacity
        {
            get
            {
                return utf8MaxLengthInBytes;
            }
            set
            {
                CheckCapacityInRange(value);
            }
        }

        /// <summary>
        /// Reports whether container is empty.
        /// </summary>
        /// <value>True if this container empty.</value>
        public bool IsEmpty => utf8LengthInBytes == 0;

        /// <summary>
        /// Return the byte at the given byte (not character) index.  The index
        /// must be in the range of [0..Length)
        /// </summary>
        public byte this[int index]
        {
            get
            {
                unsafe
                {
                    CheckIndexInRange(index);
                    return GetUnsafePtr()[index];
                }
            }

            set
            {
                unsafe
                {
                    CheckIndexInRange(index);
                    GetUnsafePtr()[index] = value;
                }
            }
        }

        /// <summary>
        /// Return a ref to the the byte at the given byte (not character) index.  The index
        /// must be in the range of [0..Length).  The ref byte is a direct reference into
        /// this FixedString, and is only valid while this FixedString is valid.
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public ref byte ElementAt(int index)
        {
            unsafe
            {
                CheckIndexInRange(index);
                return ref GetUnsafePtr()[index];
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public void Clear()
        {
            Length = 0;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="value"></param>
        public void Add(in byte value)
        {
            this[Length++] = value;
        }

        /// <summary>
        /// <undoc />
        /// </summary>
        public struct Enumerator : IEnumerator
        {
            FixedString32 target;
            int offset;
            Unicode.Rune current;

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <param name="other"><undoc /></param>
            public Enumerator(FixedString32 other)
            {
                target = other;
                offset = 0;
                current = default;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Dispose()
            {
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <returns><undoc /></returns>
            public bool MoveNext()
            {
                if (offset >= target.Length)
                    return false;

                unsafe
                {
                    Unicode.Utf8ToUcs(out current, target.GetUnsafePtr(), ref offset, target.Length);
                }

                return true;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Reset()
            {
                offset = 0;
                current = default;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public Unicode.Rune Current => current;

            object IEnumerator.Current => Current;
        }

        /// <summary>
        /// Returns an enumerator that iterates through a container.
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the container.</returns>
        public Enumerator GetEnumerator()
        {
            return new Enumerator(this);
        }

        /// <summary>
        /// Compare this FixedString32 with a System.String in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The System.String to compare with</param>
        /// <returns>
        /// -1 if this FixedString32 would appear first if sorted,
        ///  0 if they are identical, or
        ///  1 if the other System.String would appear first if sorted.
        /// </returns>
        public int CompareTo(String other)
        {
            return ToString().CompareTo(other);
        }

        /// <summary>
        /// Compare this FixedString32 with a System.String,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The System.String to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool Equals(String other)
        {
            return ToString().Equals(other);
        }

        /// <summary>
        /// Transform this struct to a reference to a FixedListByteN, which has the same layout.
        /// The returned reference is a reference to this data, and is only valid while it is valid.
        /// </summary>
        /// <returns></returns>
        public unsafe ref FixedListByte32 AsFixedList()
        {
            return ref UnsafeUtility.AsRef<FixedListByte32>(UnsafeUtility.AddressOf(ref this));
        }

        /// <summary>
        /// Construct a FixedString32 from a System.String object.
        /// </summary>
        /// <param name="source">The System.String object to construct this FixedString32 with</param>
        public FixedString32(String source)
        {
            bytes = default;
            utf8LengthInBytes = 0;
            unsafe
            {
                fixed (char* sourceptr = source)
                {
                    var error = UTF8ArrayUnsafeUtility.Copy(GetUnsafePtr(), out utf8LengthInBytes, utf8MaxLengthInBytes, sourceptr, source.Length);
                    if (error != CopyError.None)
                        throw new ArgumentException($"FixedString32: {error} while copying \"{source}\"");
                    this.Length = utf8LengthInBytes;
                }
            }
        }

        /// <summary>
        /// Compare this FixedString32 with a FixedString32 in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The FixedString to compare with</param>
        /// <returns>
        /// -1 if this FixedString32 would appear first if sorted,
        ///  0 if they are identical, or
        ///  1 if the other FixedString32 would appear first if sorted.
        /// </returns>
        public int CompareTo(FixedString32 other)
        {
            return FixedStringMethods.CompareTo(ref this, other);
        }

        /// <summary>
        /// Construct a FixedString32 by copying from another FixedString source.
        /// </summary>
        /// <param name="source"></param>
        public FixedString32(in FixedString32 source)
        {
            bytes = default;
            utf8LengthInBytes = 0;
            unsafe {
                int len = 0;
                byte* dstBytes = GetUnsafePtr();
                byte* srcBytes = (byte*) UnsafeUtilityExtensions.AddressOf(source.bytes);
                var srcLength = source.utf8LengthInBytes;
                if (UTF8ArrayUnsafeUtility.AppendUTF8Bytes(dstBytes, ref len, utf8MaxLengthInBytes, srcBytes, srcLength) != FormatError.None)
                    throw new ArgumentException("Source is too long to fit into fixed string of this size");
                this.Length = len;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator ==(in FixedString32 a, in FixedString32 b)
        {
            // this must not call any methods on 'a' or 'b'
            unsafe {
                int alen = a.utf8LengthInBytes;
                int blen = b.utf8LengthInBytes;
                byte* aptr = (byte*) UnsafeUtilityExtensions.AddressOf(a.bytes);
                byte* bptr = (byte*) UnsafeUtilityExtensions.AddressOf(b.bytes);
                return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aptr, alen, bptr, blen);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator !=(in FixedString32 a, in FixedString32 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(FixedString32 other)
        {
            return this == other;
        }

        /// <summary>
        /// Compare this FixedString32 with a FixedString64 in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The FixedString to compare with</param>
        /// <returns>
        /// -1 if this FixedString32 would appear first if sorted,
        ///  0 if they are identical, or
        ///  1 if the other FixedString64 would appear first if sorted.
        /// </returns>
        public int CompareTo(FixedString64 other)
        {
            return FixedStringMethods.CompareTo(ref this, other);
        }

        /// <summary>
        /// Construct a FixedString32 by copying from another FixedString source.
        /// </summary>
        /// <param name="source"></param>
        public FixedString32(in FixedString64 source)
        {
            bytes = default;
            utf8LengthInBytes = 0;
            unsafe {
                int len = 0;
                byte* dstBytes = GetUnsafePtr();
                byte* srcBytes = (byte*) UnsafeUtilityExtensions.AddressOf(source.bytes);
                var srcLength = source.utf8LengthInBytes;
                if (UTF8ArrayUnsafeUtility.AppendUTF8Bytes(dstBytes, ref len, utf8MaxLengthInBytes, srcBytes, srcLength) != FormatError.None)
                    throw new ArgumentException("Source is too long to fit into fixed string of this size");
                this.Length = len;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator ==(in FixedString32 a, in FixedString64 b)
        {
            // this must not call any methods on 'a' or 'b'
            unsafe {
                int alen = a.utf8LengthInBytes;
                int blen = b.utf8LengthInBytes;
                byte* aptr = (byte*) UnsafeUtilityExtensions.AddressOf(a.bytes);
                byte* bptr = (byte*) UnsafeUtilityExtensions.AddressOf(b.bytes);
                return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aptr, alen, bptr, blen);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator !=(in FixedString32 a, in FixedString64 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(FixedString64 other)
        {
            return this == other;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="fs"></param>
        /// <returns></returns>
        public static implicit operator FixedString64(in FixedString32 fs) => new FixedString64(in fs);

        /// <summary>
        /// Compare this FixedString32 with a FixedString128 in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The FixedString to compare with</param>
        /// <returns>
        /// -1 if this FixedString32 would appear first if sorted,
        ///  0 if they are identical, or
        ///  1 if the other FixedString128 would appear first if sorted.
        /// </returns>
        public int CompareTo(FixedString128 other)
        {
            return FixedStringMethods.CompareTo(ref this, other);
        }

        /// <summary>
        /// Construct a FixedString32 by copying from another FixedString source.
        /// </summary>
        /// <param name="source"></param>
        public FixedString32(in FixedString128 source)
        {
            bytes = default;
            utf8LengthInBytes = 0;
            unsafe {
                int len = 0;
                byte* dstBytes = GetUnsafePtr();
                byte* srcBytes = (byte*) UnsafeUtilityExtensions.AddressOf(source.bytes);
                var srcLength = source.utf8LengthInBytes;
                if (UTF8ArrayUnsafeUtility.AppendUTF8Bytes(dstBytes, ref len, utf8MaxLengthInBytes, srcBytes, srcLength) != FormatError.None)
                    throw new ArgumentException("Source is too long to fit into fixed string of this size");
                this.Length = len;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator ==(in FixedString32 a, in FixedString128 b)
        {
            // this must not call any methods on 'a' or 'b'
            unsafe {
                int alen = a.utf8LengthInBytes;
                int blen = b.utf8LengthInBytes;
                byte* aptr = (byte*) UnsafeUtilityExtensions.AddressOf(a.bytes);
                byte* bptr = (byte*) UnsafeUtilityExtensions.AddressOf(b.bytes);
                return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aptr, alen, bptr, blen);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator !=(in FixedString32 a, in FixedString128 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(FixedString128 other)
        {
            return this == other;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="fs"></param>
        /// <returns></returns>
        public static implicit operator FixedString128(in FixedString32 fs) => new FixedString128(in fs);

        /// <summary>
        /// Compare this FixedString32 with a FixedString512 in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The FixedString to compare with</param>
        /// <returns>
        /// -1 if this FixedString32 would appear first if sorted,
        ///  0 if they are identical, or
        ///  1 if the other FixedString512 would appear first if sorted.
        /// </returns>
        public int CompareTo(FixedString512 other)
        {
            return FixedStringMethods.CompareTo(ref this, other);
        }

        /// <summary>
        /// Construct a FixedString32 by copying from another FixedString source.
        /// </summary>
        /// <param name="source"></param>
        public FixedString32(in FixedString512 source)
        {
            bytes = default;
            utf8LengthInBytes = 0;
            unsafe {
                int len = 0;
                byte* dstBytes = GetUnsafePtr();
                byte* srcBytes = (byte*) UnsafeUtilityExtensions.AddressOf(source.bytes);
                var srcLength = source.utf8LengthInBytes;
                if (UTF8ArrayUnsafeUtility.AppendUTF8Bytes(dstBytes, ref len, utf8MaxLengthInBytes, srcBytes, srcLength) != FormatError.None)
                    throw new ArgumentException("Source is too long to fit into fixed string of this size");
                this.Length = len;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator ==(in FixedString32 a, in FixedString512 b)
        {
            // this must not call any methods on 'a' or 'b'
            unsafe {
                int alen = a.utf8LengthInBytes;
                int blen = b.utf8LengthInBytes;
                byte* aptr = (byte*) UnsafeUtilityExtensions.AddressOf(a.bytes);
                byte* bptr = (byte*) UnsafeUtilityExtensions.AddressOf(b.bytes);
                return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aptr, alen, bptr, blen);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator !=(in FixedString32 a, in FixedString512 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(FixedString512 other)
        {
            return this == other;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="fs"></param>
        /// <returns></returns>
        public static implicit operator FixedString512(in FixedString32 fs) => new FixedString512(in fs);

        /// <summary>
        /// Compare this FixedString32 with a FixedString4096 in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The FixedString to compare with</param>
        /// <returns>
        /// -1 if this FixedString32 would appear first if sorted,
        ///  0 if they are identical, or
        ///  1 if the other FixedString4096 would appear first if sorted.
        /// </returns>
        public int CompareTo(FixedString4096 other)
        {
            return FixedStringMethods.CompareTo(ref this, other);
        }

        /// <summary>
        /// Construct a FixedString32 by copying from another FixedString source.
        /// </summary>
        /// <param name="source"></param>
        public FixedString32(in FixedString4096 source)
        {
            bytes = default;
            utf8LengthInBytes = 0;
            unsafe {
                int len = 0;
                byte* dstBytes = GetUnsafePtr();
                byte* srcBytes = (byte*) UnsafeUtilityExtensions.AddressOf(source.bytes);
                var srcLength = source.utf8LengthInBytes;
                if (UTF8ArrayUnsafeUtility.AppendUTF8Bytes(dstBytes, ref len, utf8MaxLengthInBytes, srcBytes, srcLength) != FormatError.None)
                    throw new ArgumentException("Source is too long to fit into fixed string of this size");
                this.Length = len;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator ==(in FixedString32 a, in FixedString4096 b)
        {
            // this must not call any methods on 'a' or 'b'
            unsafe {
                int alen = a.utf8LengthInBytes;
                int blen = b.utf8LengthInBytes;
                byte* aptr = (byte*) UnsafeUtilityExtensions.AddressOf(a.bytes);
                byte* bptr = (byte*) UnsafeUtilityExtensions.AddressOf(b.bytes);
                return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aptr, alen, bptr, blen);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator !=(in FixedString32 a, in FixedString4096 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(FixedString4096 other)
        {
            return this == other;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="fs"></param>
        /// <returns></returns>
        public static implicit operator FixedString4096(in FixedString32 fs) => new FixedString4096(in fs);

        /// <summary>
        /// Enable implicit conversion of System.String to FixedString32.
        /// </summary>
        /// <param name="b">The System.String object to convert to a FixedString32</param>
        /// <returns></returns>
        public static implicit operator FixedString32(string b) => new FixedString32(b);

        /// <summary>
        /// Convert this FixedString32 to a System.String.
        /// </summary>
        /// <returns>A System.String with a copy of this FixedString32</returns>
        public override String ToString()
        {
            return this.ConvertToString();
        }

        /// <summary>
        /// Compute a hash code of this FixedString32: an integer that is likely to be different for
        /// two FixedString32, if their contents are different.
        /// </summary>
        /// <returns>A hash code of this FixedString32</returns>
        public override int GetHashCode()
        {
            return this.ComputeHashCode();
        }

        /// <summary>
        /// Determines whether a FixedString32 has the same value as some other object.
        /// </summary>
        /// <param name="obj">The object to compare for equality</param>
        /// <returns></returns>
        public override bool Equals(object obj)
        {
            if(ReferenceEquals(null, obj)) return false;
            if(obj is String aString) return Equals(aString);
            if(obj is FixedString32 aFixedString32) return Equals(aFixedString32);
            if(obj is FixedString64 aFixedString64) return Equals(aFixedString64);
            if(obj is FixedString128 aFixedString128) return Equals(aFixedString128);
            if(obj is FixedString512 aFixedString512) return Equals(aFixedString512);
            if(obj is FixedString4096 aFixedString4096) return Equals(aFixedString4096);
            return false;
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        void CheckIndexInRange(int index)
        {
            if (index < 0)
                throw new IndexOutOfRangeException($"Index {index} must be positive.");
            if (index >= utf8LengthInBytes)
                throw new IndexOutOfRangeException($"Index {index} is out of range in FixedString32 of '{utf8LengthInBytes}' Length.");
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        void CheckLengthInRange(int length)
        {
            if (length < 0)
                throw new ArgumentOutOfRangeException($"Length {length} must be positive.");
            if (length > utf8MaxLengthInBytes)
                throw new ArgumentOutOfRangeException($"Length {length} is out of range in FixedString32 of '{utf8MaxLengthInBytes}' Capacity.");
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        void CheckCapacityInRange(int capacity)
        {
            if (capacity != Capacity)
                throw new ArgumentOutOfRangeException($"Capacity {capacity} must be {Capacity}.");
        }
    }

    [StructLayout(LayoutKind.Explicit, Size=62)]
    internal struct FixedBytes62
    {
        [FieldOffset(0)] internal FixedBytes16 offset0000;
        [FieldOffset(16)] internal FixedBytes16 offset0016;
        [FieldOffset(32)] internal FixedBytes16 offset0032;
        [FieldOffset(48)] internal byte byte0048;
        [FieldOffset(49)] internal byte byte0049;
        [FieldOffset(50)] internal byte byte0050;
        [FieldOffset(51)] internal byte byte0051;
        [FieldOffset(52)] internal byte byte0052;
        [FieldOffset(53)] internal byte byte0053;
        [FieldOffset(54)] internal byte byte0054;
        [FieldOffset(55)] internal byte byte0055;
        [FieldOffset(56)] internal byte byte0056;
        [FieldOffset(57)] internal byte byte0057;
        [FieldOffset(58)] internal byte byte0058;
        [FieldOffset(59)] internal byte byte0059;
        [FieldOffset(60)] internal byte byte0060;
        [FieldOffset(61)] internal byte byte0061;
    }

    /// <summary>
    /// An unmanaged string in UTF-8 format that contains its own fixed-size buffer of the given size in bytes.
    /// The string is NOT guaranteed to be null-terminated, though in many cases it may be by accident.
    /// No memory is ever allocated, and no attempt is made to share memory when strings are copied.
    /// Since this structure is not generic and needs no disposing, it can exist inside ECS components,
    /// can be put in a FixedArray, FixedList or FixedHashMap, and can be a data member of unmanaged structs
    /// that are allocated from the unmanaged heap. This string is entirely compatible with Burst compilation.
    ///
    /// The binary layout of this string is guaranteed, for now and all time, to be two bytes of little-endian length,
    /// followed by a contiguous array of bytes with that length, with no padding in between. This is intentionally
    /// identical to FixedList of byte, which is guaranteed to always have the same memory layout.
    ///
    /// Those who need more than 65,535 contiguous items should allocate from the heap, as storing that many things
    /// contiguously in a C# struct is likely to result in much wasted time, as the compiler copies the struct often.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Size=64)]
    public partial struct FixedString64
        : INativeList<byte>
        , IUTF8Bytes
        , IComparable<String>
        , IEquatable<String>
        , IComparable<FixedString32>
        , IEquatable<FixedString32>
        , IComparable<FixedString64>
        , IEquatable<FixedString64>
        , IComparable<FixedString128>
        , IEquatable<FixedString128>
        , IComparable<FixedString512>
        , IEquatable<FixedString512>
        , IComparable<FixedString4096>
        , IEquatable<FixedString4096>
    {
        internal const ushort utf8MaxLengthInBytes = 61;

        internal ushort utf8LengthInBytes;
        internal FixedBytes62 bytes;

        /// <summary>
        /// Returns the maximum number of utf8 bytes that can be stored in this type.
        /// </summary>
        public static int UTF8MaxLengthInBytes => utf8MaxLengthInBytes;

        /// <summary>
        /// A property in order to display the value in Unity.Properties generated UI.
        /// </summary>
        [CreateProperty]
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public string Value => ToString();

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe byte* GetUnsafePtr()
        {
            return (byte*) UnsafeUtility.AddressOf(ref bytes);
        }

        //
        // INativeList<byte> methods
        //

        /// <summary>
        /// The current length of the UTF-8 encoded string, in bytes.
        /// The string is guaranteed to he null-terminated.  The length value
        /// does not include the null terminating byte.
        /// </summary>
        public int Length
        {
            get
            {
                return utf8LengthInBytes;
            }
            set
            {
                CheckLengthInRange(value);
                utf8LengthInBytes = (ushort)value;
                unsafe
                {
                    GetUnsafePtr()[utf8LengthInBytes] = 0;
                }
            }
        }

        /// <summary>
        /// <undoc />
        /// </summary>
        [Obsolete("UTF8LengthInBytes has been renamed to just Length. (RemovedAfter 2020-08-01) (UnityUpgradable) -> Length", true)]
        public int UTF8LengthInBytes => Length;

        /// <summary>
        /// The maximum length of the UTF-8 encopded string, in bytes.
        /// Due to the UTF-8 encoding, each Unicode code point requires between 1 and 4 bytes to encode.
        /// The null terminating byte is not included in the capacity.  The FixedString always
        /// has space for a null terminating byte.
        /// </summary>
        public int Capacity
        {
            get
            {
                return utf8MaxLengthInBytes;
            }
            set
            {
                CheckCapacityInRange(value);
            }
        }

        /// <summary>
        /// Reports whether container is empty.
        /// </summary>
        /// <value>True if this container empty.</value>
        public bool IsEmpty => utf8LengthInBytes == 0;

        /// <summary>
        /// Return the byte at the given byte (not character) index.  The index
        /// must be in the range of [0..Length)
        /// </summary>
        public byte this[int index]
        {
            get
            {
                unsafe
                {
                    CheckIndexInRange(index);
                    return GetUnsafePtr()[index];
                }
            }

            set
            {
                unsafe
                {
                    CheckIndexInRange(index);
                    GetUnsafePtr()[index] = value;
                }
            }
        }

        /// <summary>
        /// Return a ref to the the byte at the given byte (not character) index.  The index
        /// must be in the range of [0..Length).  The ref byte is a direct reference into
        /// this FixedString, and is only valid while this FixedString is valid.
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public ref byte ElementAt(int index)
        {
            unsafe
            {
                CheckIndexInRange(index);
                return ref GetUnsafePtr()[index];
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public void Clear()
        {
            Length = 0;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="value"></param>
        public void Add(in byte value)
        {
            this[Length++] = value;
        }

        /// <summary>
        /// <undoc />
        /// </summary>
        public struct Enumerator : IEnumerator
        {
            FixedString64 target;
            int offset;
            Unicode.Rune current;

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <param name="other"><undoc /></param>
            public Enumerator(FixedString64 other)
            {
                target = other;
                offset = 0;
                current = default;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Dispose()
            {
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <returns><undoc /></returns>
            public bool MoveNext()
            {
                if (offset >= target.Length)
                    return false;

                unsafe
                {
                    Unicode.Utf8ToUcs(out current, target.GetUnsafePtr(), ref offset, target.Length);
                }

                return true;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Reset()
            {
                offset = 0;
                current = default;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public Unicode.Rune Current => current;

            object IEnumerator.Current => Current;
        }

        /// <summary>
        /// Returns an enumerator that iterates through a container.
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the container.</returns>
        public Enumerator GetEnumerator()
        {
            return new Enumerator(this);
        }

        /// <summary>
        /// Compare this FixedString64 with a System.String in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The System.String to compare with</param>
        /// <returns>
        /// -1 if this FixedString64 would appear first if sorted,
        ///  0 if they are identical, or
        ///  1 if the other System.String would appear first if sorted.
        /// </returns>
        public int CompareTo(String other)
        {
            return ToString().CompareTo(other);
        }

        /// <summary>
        /// Compare this FixedString64 with a System.String,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The System.String to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool Equals(String other)
        {
            return ToString().Equals(other);
        }

        /// <summary>
        /// Transform this struct to a reference to a FixedListByteN, which has the same layout.
        /// The returned reference is a reference to this data, and is only valid while it is valid.
        /// </summary>
        /// <returns></returns>
        public unsafe ref FixedListByte64 AsFixedList()
        {
            return ref UnsafeUtility.AsRef<FixedListByte64>(UnsafeUtility.AddressOf(ref this));
        }

        /// <summary>
        /// Construct a FixedString64 from a System.String object.
        /// </summary>
        /// <param name="source">The System.String object to construct this FixedString64 with</param>
        public FixedString64(String source)
        {
            bytes = default;
            utf8LengthInBytes = 0;
            unsafe
            {
                fixed (char* sourceptr = source)
                {
                    var error = UTF8ArrayUnsafeUtility.Copy(GetUnsafePtr(), out utf8LengthInBytes, utf8MaxLengthInBytes, sourceptr, source.Length);
                    if (error != CopyError.None)
                        throw new ArgumentException($"FixedString32: {error} while copying \"{source}\"");
                    this.Length = utf8LengthInBytes;
                }
            }
        }

        /// <summary>
        /// Compare this FixedString64 with a FixedString32 in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The FixedString to compare with</param>
        /// <returns>
        /// -1 if this FixedString64 would appear first if sorted,
        ///  0 if they are identical, or
        ///  1 if the other FixedString32 would appear first if sorted.
        /// </returns>
        public int CompareTo(FixedString32 other)
        {
            return FixedStringMethods.CompareTo(ref this, other);
        }

        /// <summary>
        /// Construct a FixedString64 by copying from another FixedString source.
        /// </summary>
        /// <param name="source"></param>
        public FixedString64(in FixedString32 source)
        {
            bytes = default;
            utf8LengthInBytes = 0;
            unsafe {
                int len = 0;
                byte* dstBytes = GetUnsafePtr();
                byte* srcBytes = (byte*) UnsafeUtilityExtensions.AddressOf(source.bytes);
                var srcLength = source.utf8LengthInBytes;
                if (UTF8ArrayUnsafeUtility.AppendUTF8Bytes(dstBytes, ref len, utf8MaxLengthInBytes, srcBytes, srcLength) != FormatError.None)
                    throw new ArgumentException("Source is too long to fit into fixed string of this size");
                this.Length = len;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator ==(in FixedString64 a, in FixedString32 b)
        {
            // this must not call any methods on 'a' or 'b'
            unsafe {
                int alen = a.utf8LengthInBytes;
                int blen = b.utf8LengthInBytes;
                byte* aptr = (byte*) UnsafeUtilityExtensions.AddressOf(a.bytes);
                byte* bptr = (byte*) UnsafeUtilityExtensions.AddressOf(b.bytes);
                return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aptr, alen, bptr, blen);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator !=(in FixedString64 a, in FixedString32 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(FixedString32 other)
        {
            return this == other;
        }

        /// <summary>
        /// Compare this FixedString64 with a FixedString64 in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The FixedString to compare with</param>
        /// <returns>
        /// -1 if this FixedString64 would appear first if sorted,
        ///  0 if they are identical, or
        ///  1 if the other FixedString64 would appear first if sorted.
        /// </returns>
        public int CompareTo(FixedString64 other)
        {
            return FixedStringMethods.CompareTo(ref this, other);
        }

        /// <summary>
        /// Construct a FixedString64 by copying from another FixedString source.
        /// </summary>
        /// <param name="source"></param>
        public FixedString64(in FixedString64 source)
        {
            bytes = default;
            utf8LengthInBytes = 0;
            unsafe {
                int len = 0;
                byte* dstBytes = GetUnsafePtr();
                byte* srcBytes = (byte*) UnsafeUtilityExtensions.AddressOf(source.bytes);
                var srcLength = source.utf8LengthInBytes;
                if (UTF8ArrayUnsafeUtility.AppendUTF8Bytes(dstBytes, ref len, utf8MaxLengthInBytes, srcBytes, srcLength) != FormatError.None)
                    throw new ArgumentException("Source is too long to fit into fixed string of this size");
                this.Length = len;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator ==(in FixedString64 a, in FixedString64 b)
        {
            // this must not call any methods on 'a' or 'b'
            unsafe {
                int alen = a.utf8LengthInBytes;
                int blen = b.utf8LengthInBytes;
                byte* aptr = (byte*) UnsafeUtilityExtensions.AddressOf(a.bytes);
                byte* bptr = (byte*) UnsafeUtilityExtensions.AddressOf(b.bytes);
                return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aptr, alen, bptr, blen);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator !=(in FixedString64 a, in FixedString64 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(FixedString64 other)
        {
            return this == other;
        }

        /// <summary>
        /// Compare this FixedString64 with a FixedString128 in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The FixedString to compare with</param>
        /// <returns>
        /// -1 if this FixedString64 would appear first if sorted,
        ///  0 if they are identical, or
        ///  1 if the other FixedString128 would appear first if sorted.
        /// </returns>
        public int CompareTo(FixedString128 other)
        {
            return FixedStringMethods.CompareTo(ref this, other);
        }

        /// <summary>
        /// Construct a FixedString64 by copying from another FixedString source.
        /// </summary>
        /// <param name="source"></param>
        public FixedString64(in FixedString128 source)
        {
            bytes = default;
            utf8LengthInBytes = 0;
            unsafe {
                int len = 0;
                byte* dstBytes = GetUnsafePtr();
                byte* srcBytes = (byte*) UnsafeUtilityExtensions.AddressOf(source.bytes);
                var srcLength = source.utf8LengthInBytes;
                if (UTF8ArrayUnsafeUtility.AppendUTF8Bytes(dstBytes, ref len, utf8MaxLengthInBytes, srcBytes, srcLength) != FormatError.None)
                    throw new ArgumentException("Source is too long to fit into fixed string of this size");
                this.Length = len;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator ==(in FixedString64 a, in FixedString128 b)
        {
            // this must not call any methods on 'a' or 'b'
            unsafe {
                int alen = a.utf8LengthInBytes;
                int blen = b.utf8LengthInBytes;
                byte* aptr = (byte*) UnsafeUtilityExtensions.AddressOf(a.bytes);
                byte* bptr = (byte*) UnsafeUtilityExtensions.AddressOf(b.bytes);
                return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aptr, alen, bptr, blen);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator !=(in FixedString64 a, in FixedString128 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(FixedString128 other)
        {
            return this == other;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="fs"></param>
        /// <returns></returns>
        public static implicit operator FixedString128(in FixedString64 fs) => new FixedString128(in fs);

        /// <summary>
        /// Compare this FixedString64 with a FixedString512 in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The FixedString to compare with</param>
        /// <returns>
        /// -1 if this FixedString64 would appear first if sorted,
        ///  0 if they are identical, or
        ///  1 if the other FixedString512 would appear first if sorted.
        /// </returns>
        public int CompareTo(FixedString512 other)
        {
            return FixedStringMethods.CompareTo(ref this, other);
        }

        /// <summary>
        /// Construct a FixedString64 by copying from another FixedString source.
        /// </summary>
        /// <param name="source"></param>
        public FixedString64(in FixedString512 source)
        {
            bytes = default;
            utf8LengthInBytes = 0;
            unsafe {
                int len = 0;
                byte* dstBytes = GetUnsafePtr();
                byte* srcBytes = (byte*) UnsafeUtilityExtensions.AddressOf(source.bytes);
                var srcLength = source.utf8LengthInBytes;
                if (UTF8ArrayUnsafeUtility.AppendUTF8Bytes(dstBytes, ref len, utf8MaxLengthInBytes, srcBytes, srcLength) != FormatError.None)
                    throw new ArgumentException("Source is too long to fit into fixed string of this size");
                this.Length = len;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator ==(in FixedString64 a, in FixedString512 b)
        {
            // this must not call any methods on 'a' or 'b'
            unsafe {
                int alen = a.utf8LengthInBytes;
                int blen = b.utf8LengthInBytes;
                byte* aptr = (byte*) UnsafeUtilityExtensions.AddressOf(a.bytes);
                byte* bptr = (byte*) UnsafeUtilityExtensions.AddressOf(b.bytes);
                return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aptr, alen, bptr, blen);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator !=(in FixedString64 a, in FixedString512 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(FixedString512 other)
        {
            return this == other;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="fs"></param>
        /// <returns></returns>
        public static implicit operator FixedString512(in FixedString64 fs) => new FixedString512(in fs);

        /// <summary>
        /// Compare this FixedString64 with a FixedString4096 in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The FixedString to compare with</param>
        /// <returns>
        /// -1 if this FixedString64 would appear first if sorted,
        ///  0 if they are identical, or
        ///  1 if the other FixedString4096 would appear first if sorted.
        /// </returns>
        public int CompareTo(FixedString4096 other)
        {
            return FixedStringMethods.CompareTo(ref this, other);
        }

        /// <summary>
        /// Construct a FixedString64 by copying from another FixedString source.
        /// </summary>
        /// <param name="source"></param>
        public FixedString64(in FixedString4096 source)
        {
            bytes = default;
            utf8LengthInBytes = 0;
            unsafe {
                int len = 0;
                byte* dstBytes = GetUnsafePtr();
                byte* srcBytes = (byte*) UnsafeUtilityExtensions.AddressOf(source.bytes);
                var srcLength = source.utf8LengthInBytes;
                if (UTF8ArrayUnsafeUtility.AppendUTF8Bytes(dstBytes, ref len, utf8MaxLengthInBytes, srcBytes, srcLength) != FormatError.None)
                    throw new ArgumentException("Source is too long to fit into fixed string of this size");
                this.Length = len;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator ==(in FixedString64 a, in FixedString4096 b)
        {
            // this must not call any methods on 'a' or 'b'
            unsafe {
                int alen = a.utf8LengthInBytes;
                int blen = b.utf8LengthInBytes;
                byte* aptr = (byte*) UnsafeUtilityExtensions.AddressOf(a.bytes);
                byte* bptr = (byte*) UnsafeUtilityExtensions.AddressOf(b.bytes);
                return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aptr, alen, bptr, blen);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator !=(in FixedString64 a, in FixedString4096 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(FixedString4096 other)
        {
            return this == other;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="fs"></param>
        /// <returns></returns>
        public static implicit operator FixedString4096(in FixedString64 fs) => new FixedString4096(in fs);

        /// <summary>
        /// Enable implicit conversion of System.String to FixedString64.
        /// </summary>
        /// <param name="b">The System.String object to convert to a FixedString64</param>
        /// <returns></returns>
        public static implicit operator FixedString64(string b) => new FixedString64(b);

        /// <summary>
        /// Convert this FixedString64 to a System.String.
        /// </summary>
        /// <returns>A System.String with a copy of this FixedString64</returns>
        public override String ToString()
        {
            return this.ConvertToString();
        }

        /// <summary>
        /// Compute a hash code of this FixedString64: an integer that is likely to be different for
        /// two FixedString64, if their contents are different.
        /// </summary>
        /// <returns>A hash code of this FixedString64</returns>
        public override int GetHashCode()
        {
            return this.ComputeHashCode();
        }

        /// <summary>
        /// Determines whether a FixedString64 has the same value as some other object.
        /// </summary>
        /// <param name="obj">The object to compare for equality</param>
        /// <returns></returns>
        public override bool Equals(object obj)
        {
            if(ReferenceEquals(null, obj)) return false;
            if(obj is String aString) return Equals(aString);
            if(obj is FixedString32 aFixedString32) return Equals(aFixedString32);
            if(obj is FixedString64 aFixedString64) return Equals(aFixedString64);
            if(obj is FixedString128 aFixedString128) return Equals(aFixedString128);
            if(obj is FixedString512 aFixedString512) return Equals(aFixedString512);
            if(obj is FixedString4096 aFixedString4096) return Equals(aFixedString4096);
            return false;
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        void CheckIndexInRange(int index)
        {
            if (index < 0)
                throw new IndexOutOfRangeException($"Index {index} must be positive.");
            if (index >= utf8LengthInBytes)
                throw new IndexOutOfRangeException($"Index {index} is out of range in FixedString64 of '{utf8LengthInBytes}' Length.");
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        void CheckLengthInRange(int length)
        {
            if (length < 0)
                throw new ArgumentOutOfRangeException($"Length {length} must be positive.");
            if (length > utf8MaxLengthInBytes)
                throw new ArgumentOutOfRangeException($"Length {length} is out of range in FixedString64 of '{utf8MaxLengthInBytes}' Capacity.");
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        void CheckCapacityInRange(int capacity)
        {
            if (capacity != Capacity)
                throw new ArgumentOutOfRangeException($"Capacity {capacity} must be {Capacity}.");
        }
    }

    [StructLayout(LayoutKind.Explicit, Size=126)]
    internal struct FixedBytes126
    {
        [FieldOffset(0)] internal FixedBytes16 offset0000;
        [FieldOffset(16)] internal FixedBytes16 offset0016;
        [FieldOffset(32)] internal FixedBytes16 offset0032;
        [FieldOffset(48)] internal FixedBytes16 offset0048;
        [FieldOffset(64)] internal FixedBytes16 offset0064;
        [FieldOffset(80)] internal FixedBytes16 offset0080;
        [FieldOffset(96)] internal FixedBytes16 offset0096;
        [FieldOffset(112)] internal byte byte0112;
        [FieldOffset(113)] internal byte byte0113;
        [FieldOffset(114)] internal byte byte0114;
        [FieldOffset(115)] internal byte byte0115;
        [FieldOffset(116)] internal byte byte0116;
        [FieldOffset(117)] internal byte byte0117;
        [FieldOffset(118)] internal byte byte0118;
        [FieldOffset(119)] internal byte byte0119;
        [FieldOffset(120)] internal byte byte0120;
        [FieldOffset(121)] internal byte byte0121;
        [FieldOffset(122)] internal byte byte0122;
        [FieldOffset(123)] internal byte byte0123;
        [FieldOffset(124)] internal byte byte0124;
        [FieldOffset(125)] internal byte byte0125;
    }

    /// <summary>
    /// An unmanaged string in UTF-8 format that contains its own fixed-size buffer of the given size in bytes.
    /// The string is NOT guaranteed to be null-terminated, though in many cases it may be by accident.
    /// No memory is ever allocated, and no attempt is made to share memory when strings are copied.
    /// Since this structure is not generic and needs no disposing, it can exist inside ECS components,
    /// can be put in a FixedArray, FixedList or FixedHashMap, and can be a data member of unmanaged structs
    /// that are allocated from the unmanaged heap. This string is entirely compatible with Burst compilation.
    ///
    /// The binary layout of this string is guaranteed, for now and all time, to be two bytes of little-endian length,
    /// followed by a contiguous array of bytes with that length, with no padding in between. This is intentionally
    /// identical to FixedList of byte, which is guaranteed to always have the same memory layout.
    ///
    /// Those who need more than 65,535 contiguous items should allocate from the heap, as storing that many things
    /// contiguously in a C# struct is likely to result in much wasted time, as the compiler copies the struct often.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Size=128)]
    public partial struct FixedString128
        : INativeList<byte>
        , IUTF8Bytes
        , IComparable<String>
        , IEquatable<String>
        , IComparable<FixedString32>
        , IEquatable<FixedString32>
        , IComparable<FixedString64>
        , IEquatable<FixedString64>
        , IComparable<FixedString128>
        , IEquatable<FixedString128>
        , IComparable<FixedString512>
        , IEquatable<FixedString512>
        , IComparable<FixedString4096>
        , IEquatable<FixedString4096>
    {
        internal const ushort utf8MaxLengthInBytes = 125;

        internal ushort utf8LengthInBytes;
        internal FixedBytes126 bytes;

        /// <summary>
        /// Returns the maximum number of utf8 bytes that can be stored in this type.
        /// </summary>
        public static int UTF8MaxLengthInBytes => utf8MaxLengthInBytes;

        /// <summary>
        /// A property in order to display the value in Unity.Properties generated UI.
        /// </summary>
        [CreateProperty]
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public string Value => ToString();

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe byte* GetUnsafePtr()
        {
            return (byte*) UnsafeUtility.AddressOf(ref bytes);
        }

        //
        // INativeList<byte> methods
        //

        /// <summary>
        /// The current length of the UTF-8 encoded string, in bytes.
        /// The string is guaranteed to he null-terminated.  The length value
        /// does not include the null terminating byte.
        /// </summary>
        public int Length
        {
            get
            {
                return utf8LengthInBytes;
            }
            set
            {
                CheckLengthInRange(value);
                utf8LengthInBytes = (ushort)value;
                unsafe
                {
                    GetUnsafePtr()[utf8LengthInBytes] = 0;
                }
            }
        }

        /// <summary>
        /// <undoc />
        /// </summary>
        [Obsolete("UTF8LengthInBytes has been renamed to just Length. (RemovedAfter 2020-08-01) (UnityUpgradable) -> Length", true)]
        public int UTF8LengthInBytes => Length;

        /// <summary>
        /// The maximum length of the UTF-8 encopded string, in bytes.
        /// Due to the UTF-8 encoding, each Unicode code point requires between 1 and 4 bytes to encode.
        /// The null terminating byte is not included in the capacity.  The FixedString always
        /// has space for a null terminating byte.
        /// </summary>
        public int Capacity
        {
            get
            {
                return utf8MaxLengthInBytes;
            }
            set
            {
                CheckCapacityInRange(value);
            }
        }

        /// <summary>
        /// Reports whether container is empty.
        /// </summary>
        /// <value>True if this container empty.</value>
        public bool IsEmpty => utf8LengthInBytes == 0;

        /// <summary>
        /// Return the byte at the given byte (not character) index.  The index
        /// must be in the range of [0..Length)
        /// </summary>
        public byte this[int index]
        {
            get
            {
                unsafe
                {
                    CheckIndexInRange(index);
                    return GetUnsafePtr()[index];
                }
            }

            set
            {
                unsafe
                {
                    CheckIndexInRange(index);
                    GetUnsafePtr()[index] = value;
                }
            }
        }

        /// <summary>
        /// Return a ref to the the byte at the given byte (not character) index.  The index
        /// must be in the range of [0..Length).  The ref byte is a direct reference into
        /// this FixedString, and is only valid while this FixedString is valid.
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public ref byte ElementAt(int index)
        {
            unsafe
            {
                CheckIndexInRange(index);
                return ref GetUnsafePtr()[index];
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public void Clear()
        {
            Length = 0;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="value"></param>
        public void Add(in byte value)
        {
            this[Length++] = value;
        }

        /// <summary>
        /// <undoc />
        /// </summary>
        public struct Enumerator : IEnumerator
        {
            FixedString128 target;
            int offset;
            Unicode.Rune current;

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <param name="other"><undoc /></param>
            public Enumerator(FixedString128 other)
            {
                target = other;
                offset = 0;
                current = default;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Dispose()
            {
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <returns><undoc /></returns>
            public bool MoveNext()
            {
                if (offset >= target.Length)
                    return false;

                unsafe
                {
                    Unicode.Utf8ToUcs(out current, target.GetUnsafePtr(), ref offset, target.Length);
                }

                return true;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Reset()
            {
                offset = 0;
                current = default;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public Unicode.Rune Current => current;

            object IEnumerator.Current => Current;
        }

        /// <summary>
        /// Returns an enumerator that iterates through a container.
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the container.</returns>
        public Enumerator GetEnumerator()
        {
            return new Enumerator(this);
        }

        /// <summary>
        /// Compare this FixedString128 with a System.String in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The System.String to compare with</param>
        /// <returns>
        /// -1 if this FixedString128 would appear first if sorted,
        ///  0 if they are identical, or
        ///  1 if the other System.String would appear first if sorted.
        /// </returns>
        public int CompareTo(String other)
        {
            return ToString().CompareTo(other);
        }

        /// <summary>
        /// Compare this FixedString128 with a System.String,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The System.String to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool Equals(String other)
        {
            return ToString().Equals(other);
        }

        /// <summary>
        /// Transform this struct to a reference to a FixedListByteN, which has the same layout.
        /// The returned reference is a reference to this data, and is only valid while it is valid.
        /// </summary>
        /// <returns></returns>
        public unsafe ref FixedListByte128 AsFixedList()
        {
            return ref UnsafeUtility.AsRef<FixedListByte128>(UnsafeUtility.AddressOf(ref this));
        }

        /// <summary>
        /// Construct a FixedString128 from a System.String object.
        /// </summary>
        /// <param name="source">The System.String object to construct this FixedString128 with</param>
        public FixedString128(String source)
        {
            bytes = default;
            utf8LengthInBytes = 0;
            unsafe
            {
                fixed (char* sourceptr = source)
                {
                    var error = UTF8ArrayUnsafeUtility.Copy(GetUnsafePtr(), out utf8LengthInBytes, utf8MaxLengthInBytes, sourceptr, source.Length);
                    if (error != CopyError.None)
                        throw new ArgumentException($"FixedString32: {error} while copying \"{source}\"");
                    this.Length = utf8LengthInBytes;
                }
            }
        }

        /// <summary>
        /// Compare this FixedString128 with a FixedString32 in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The FixedString to compare with</param>
        /// <returns>
        /// -1 if this FixedString128 would appear first if sorted,
        ///  0 if they are identical, or
        ///  1 if the other FixedString32 would appear first if sorted.
        /// </returns>
        public int CompareTo(FixedString32 other)
        {
            return FixedStringMethods.CompareTo(ref this, other);
        }

        /// <summary>
        /// Construct a FixedString128 by copying from another FixedString source.
        /// </summary>
        /// <param name="source"></param>
        public FixedString128(in FixedString32 source)
        {
            bytes = default;
            utf8LengthInBytes = 0;
            unsafe {
                int len = 0;
                byte* dstBytes = GetUnsafePtr();
                byte* srcBytes = (byte*) UnsafeUtilityExtensions.AddressOf(source.bytes);
                var srcLength = source.utf8LengthInBytes;
                if (UTF8ArrayUnsafeUtility.AppendUTF8Bytes(dstBytes, ref len, utf8MaxLengthInBytes, srcBytes, srcLength) != FormatError.None)
                    throw new ArgumentException("Source is too long to fit into fixed string of this size");
                this.Length = len;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator ==(in FixedString128 a, in FixedString32 b)
        {
            // this must not call any methods on 'a' or 'b'
            unsafe {
                int alen = a.utf8LengthInBytes;
                int blen = b.utf8LengthInBytes;
                byte* aptr = (byte*) UnsafeUtilityExtensions.AddressOf(a.bytes);
                byte* bptr = (byte*) UnsafeUtilityExtensions.AddressOf(b.bytes);
                return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aptr, alen, bptr, blen);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator !=(in FixedString128 a, in FixedString32 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(FixedString32 other)
        {
            return this == other;
        }

        /// <summary>
        /// Compare this FixedString128 with a FixedString64 in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The FixedString to compare with</param>
        /// <returns>
        /// -1 if this FixedString128 would appear first if sorted,
        ///  0 if they are identical, or
        ///  1 if the other FixedString64 would appear first if sorted.
        /// </returns>
        public int CompareTo(FixedString64 other)
        {
            return FixedStringMethods.CompareTo(ref this, other);
        }

        /// <summary>
        /// Construct a FixedString128 by copying from another FixedString source.
        /// </summary>
        /// <param name="source"></param>
        public FixedString128(in FixedString64 source)
        {
            bytes = default;
            utf8LengthInBytes = 0;
            unsafe {
                int len = 0;
                byte* dstBytes = GetUnsafePtr();
                byte* srcBytes = (byte*) UnsafeUtilityExtensions.AddressOf(source.bytes);
                var srcLength = source.utf8LengthInBytes;
                if (UTF8ArrayUnsafeUtility.AppendUTF8Bytes(dstBytes, ref len, utf8MaxLengthInBytes, srcBytes, srcLength) != FormatError.None)
                    throw new ArgumentException("Source is too long to fit into fixed string of this size");
                this.Length = len;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator ==(in FixedString128 a, in FixedString64 b)
        {
            // this must not call any methods on 'a' or 'b'
            unsafe {
                int alen = a.utf8LengthInBytes;
                int blen = b.utf8LengthInBytes;
                byte* aptr = (byte*) UnsafeUtilityExtensions.AddressOf(a.bytes);
                byte* bptr = (byte*) UnsafeUtilityExtensions.AddressOf(b.bytes);
                return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aptr, alen, bptr, blen);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator !=(in FixedString128 a, in FixedString64 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(FixedString64 other)
        {
            return this == other;
        }

        /// <summary>
        /// Compare this FixedString128 with a FixedString128 in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The FixedString to compare with</param>
        /// <returns>
        /// -1 if this FixedString128 would appear first if sorted,
        ///  0 if they are identical, or
        ///  1 if the other FixedString128 would appear first if sorted.
        /// </returns>
        public int CompareTo(FixedString128 other)
        {
            return FixedStringMethods.CompareTo(ref this, other);
        }

        /// <summary>
        /// Construct a FixedString128 by copying from another FixedString source.
        /// </summary>
        /// <param name="source"></param>
        public FixedString128(in FixedString128 source)
        {
            bytes = default;
            utf8LengthInBytes = 0;
            unsafe {
                int len = 0;
                byte* dstBytes = GetUnsafePtr();
                byte* srcBytes = (byte*) UnsafeUtilityExtensions.AddressOf(source.bytes);
                var srcLength = source.utf8LengthInBytes;
                if (UTF8ArrayUnsafeUtility.AppendUTF8Bytes(dstBytes, ref len, utf8MaxLengthInBytes, srcBytes, srcLength) != FormatError.None)
                    throw new ArgumentException("Source is too long to fit into fixed string of this size");
                this.Length = len;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator ==(in FixedString128 a, in FixedString128 b)
        {
            // this must not call any methods on 'a' or 'b'
            unsafe {
                int alen = a.utf8LengthInBytes;
                int blen = b.utf8LengthInBytes;
                byte* aptr = (byte*) UnsafeUtilityExtensions.AddressOf(a.bytes);
                byte* bptr = (byte*) UnsafeUtilityExtensions.AddressOf(b.bytes);
                return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aptr, alen, bptr, blen);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator !=(in FixedString128 a, in FixedString128 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(FixedString128 other)
        {
            return this == other;
        }

        /// <summary>
        /// Compare this FixedString128 with a FixedString512 in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The FixedString to compare with</param>
        /// <returns>
        /// -1 if this FixedString128 would appear first if sorted,
        ///  0 if they are identical, or
        ///  1 if the other FixedString512 would appear first if sorted.
        /// </returns>
        public int CompareTo(FixedString512 other)
        {
            return FixedStringMethods.CompareTo(ref this, other);
        }

        /// <summary>
        /// Construct a FixedString128 by copying from another FixedString source.
        /// </summary>
        /// <param name="source"></param>
        public FixedString128(in FixedString512 source)
        {
            bytes = default;
            utf8LengthInBytes = 0;
            unsafe {
                int len = 0;
                byte* dstBytes = GetUnsafePtr();
                byte* srcBytes = (byte*) UnsafeUtilityExtensions.AddressOf(source.bytes);
                var srcLength = source.utf8LengthInBytes;
                if (UTF8ArrayUnsafeUtility.AppendUTF8Bytes(dstBytes, ref len, utf8MaxLengthInBytes, srcBytes, srcLength) != FormatError.None)
                    throw new ArgumentException("Source is too long to fit into fixed string of this size");
                this.Length = len;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator ==(in FixedString128 a, in FixedString512 b)
        {
            // this must not call any methods on 'a' or 'b'
            unsafe {
                int alen = a.utf8LengthInBytes;
                int blen = b.utf8LengthInBytes;
                byte* aptr = (byte*) UnsafeUtilityExtensions.AddressOf(a.bytes);
                byte* bptr = (byte*) UnsafeUtilityExtensions.AddressOf(b.bytes);
                return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aptr, alen, bptr, blen);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator !=(in FixedString128 a, in FixedString512 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(FixedString512 other)
        {
            return this == other;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="fs"></param>
        /// <returns></returns>
        public static implicit operator FixedString512(in FixedString128 fs) => new FixedString512(in fs);

        /// <summary>
        /// Compare this FixedString128 with a FixedString4096 in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The FixedString to compare with</param>
        /// <returns>
        /// -1 if this FixedString128 would appear first if sorted,
        ///  0 if they are identical, or
        ///  1 if the other FixedString4096 would appear first if sorted.
        /// </returns>
        public int CompareTo(FixedString4096 other)
        {
            return FixedStringMethods.CompareTo(ref this, other);
        }

        /// <summary>
        /// Construct a FixedString128 by copying from another FixedString source.
        /// </summary>
        /// <param name="source"></param>
        public FixedString128(in FixedString4096 source)
        {
            bytes = default;
            utf8LengthInBytes = 0;
            unsafe {
                int len = 0;
                byte* dstBytes = GetUnsafePtr();
                byte* srcBytes = (byte*) UnsafeUtilityExtensions.AddressOf(source.bytes);
                var srcLength = source.utf8LengthInBytes;
                if (UTF8ArrayUnsafeUtility.AppendUTF8Bytes(dstBytes, ref len, utf8MaxLengthInBytes, srcBytes, srcLength) != FormatError.None)
                    throw new ArgumentException("Source is too long to fit into fixed string of this size");
                this.Length = len;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator ==(in FixedString128 a, in FixedString4096 b)
        {
            // this must not call any methods on 'a' or 'b'
            unsafe {
                int alen = a.utf8LengthInBytes;
                int blen = b.utf8LengthInBytes;
                byte* aptr = (byte*) UnsafeUtilityExtensions.AddressOf(a.bytes);
                byte* bptr = (byte*) UnsafeUtilityExtensions.AddressOf(b.bytes);
                return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aptr, alen, bptr, blen);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator !=(in FixedString128 a, in FixedString4096 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(FixedString4096 other)
        {
            return this == other;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="fs"></param>
        /// <returns></returns>
        public static implicit operator FixedString4096(in FixedString128 fs) => new FixedString4096(in fs);

        /// <summary>
        /// Enable implicit conversion of System.String to FixedString128.
        /// </summary>
        /// <param name="b">The System.String object to convert to a FixedString128</param>
        /// <returns></returns>
        public static implicit operator FixedString128(string b) => new FixedString128(b);

        /// <summary>
        /// Convert this FixedString128 to a System.String.
        /// </summary>
        /// <returns>A System.String with a copy of this FixedString128</returns>
        public override String ToString()
        {
            return this.ConvertToString();
        }

        /// <summary>
        /// Compute a hash code of this FixedString128: an integer that is likely to be different for
        /// two FixedString128, if their contents are different.
        /// </summary>
        /// <returns>A hash code of this FixedString128</returns>
        public override int GetHashCode()
        {
            return this.ComputeHashCode();
        }

        /// <summary>
        /// Determines whether a FixedString128 has the same value as some other object.
        /// </summary>
        /// <param name="obj">The object to compare for equality</param>
        /// <returns></returns>
        public override bool Equals(object obj)
        {
            if(ReferenceEquals(null, obj)) return false;
            if(obj is String aString) return Equals(aString);
            if(obj is FixedString32 aFixedString32) return Equals(aFixedString32);
            if(obj is FixedString64 aFixedString64) return Equals(aFixedString64);
            if(obj is FixedString128 aFixedString128) return Equals(aFixedString128);
            if(obj is FixedString512 aFixedString512) return Equals(aFixedString512);
            if(obj is FixedString4096 aFixedString4096) return Equals(aFixedString4096);
            return false;
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        void CheckIndexInRange(int index)
        {
            if (index < 0)
                throw new IndexOutOfRangeException($"Index {index} must be positive.");
            if (index >= utf8LengthInBytes)
                throw new IndexOutOfRangeException($"Index {index} is out of range in FixedString128 of '{utf8LengthInBytes}' Length.");
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        void CheckLengthInRange(int length)
        {
            if (length < 0)
                throw new ArgumentOutOfRangeException($"Length {length} must be positive.");
            if (length > utf8MaxLengthInBytes)
                throw new ArgumentOutOfRangeException($"Length {length} is out of range in FixedString128 of '{utf8MaxLengthInBytes}' Capacity.");
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        void CheckCapacityInRange(int capacity)
        {
            if (capacity != Capacity)
                throw new ArgumentOutOfRangeException($"Capacity {capacity} must be {Capacity}.");
        }
    }

    [StructLayout(LayoutKind.Explicit, Size=510)]
    internal struct FixedBytes510
    {
        [FieldOffset(0)] internal FixedBytes16 offset0000;
        [FieldOffset(16)] internal FixedBytes16 offset0016;
        [FieldOffset(32)] internal FixedBytes16 offset0032;
        [FieldOffset(48)] internal FixedBytes16 offset0048;
        [FieldOffset(64)] internal FixedBytes16 offset0064;
        [FieldOffset(80)] internal FixedBytes16 offset0080;
        [FieldOffset(96)] internal FixedBytes16 offset0096;
        [FieldOffset(112)] internal FixedBytes16 offset0112;
        [FieldOffset(128)] internal FixedBytes16 offset0128;
        [FieldOffset(144)] internal FixedBytes16 offset0144;
        [FieldOffset(160)] internal FixedBytes16 offset0160;
        [FieldOffset(176)] internal FixedBytes16 offset0176;
        [FieldOffset(192)] internal FixedBytes16 offset0192;
        [FieldOffset(208)] internal FixedBytes16 offset0208;
        [FieldOffset(224)] internal FixedBytes16 offset0224;
        [FieldOffset(240)] internal FixedBytes16 offset0240;
        [FieldOffset(256)] internal FixedBytes16 offset0256;
        [FieldOffset(272)] internal FixedBytes16 offset0272;
        [FieldOffset(288)] internal FixedBytes16 offset0288;
        [FieldOffset(304)] internal FixedBytes16 offset0304;
        [FieldOffset(320)] internal FixedBytes16 offset0320;
        [FieldOffset(336)] internal FixedBytes16 offset0336;
        [FieldOffset(352)] internal FixedBytes16 offset0352;
        [FieldOffset(368)] internal FixedBytes16 offset0368;
        [FieldOffset(384)] internal FixedBytes16 offset0384;
        [FieldOffset(400)] internal FixedBytes16 offset0400;
        [FieldOffset(416)] internal FixedBytes16 offset0416;
        [FieldOffset(432)] internal FixedBytes16 offset0432;
        [FieldOffset(448)] internal FixedBytes16 offset0448;
        [FieldOffset(464)] internal FixedBytes16 offset0464;
        [FieldOffset(480)] internal FixedBytes16 offset0480;
        [FieldOffset(496)] internal byte byte0496;
        [FieldOffset(497)] internal byte byte0497;
        [FieldOffset(498)] internal byte byte0498;
        [FieldOffset(499)] internal byte byte0499;
        [FieldOffset(500)] internal byte byte0500;
        [FieldOffset(501)] internal byte byte0501;
        [FieldOffset(502)] internal byte byte0502;
        [FieldOffset(503)] internal byte byte0503;
        [FieldOffset(504)] internal byte byte0504;
        [FieldOffset(505)] internal byte byte0505;
        [FieldOffset(506)] internal byte byte0506;
        [FieldOffset(507)] internal byte byte0507;
        [FieldOffset(508)] internal byte byte0508;
        [FieldOffset(509)] internal byte byte0509;
    }

    /// <summary>
    /// An unmanaged string in UTF-8 format that contains its own fixed-size buffer of the given size in bytes.
    /// The string is NOT guaranteed to be null-terminated, though in many cases it may be by accident.
    /// No memory is ever allocated, and no attempt is made to share memory when strings are copied.
    /// Since this structure is not generic and needs no disposing, it can exist inside ECS components,
    /// can be put in a FixedArray, FixedList or FixedHashMap, and can be a data member of unmanaged structs
    /// that are allocated from the unmanaged heap. This string is entirely compatible with Burst compilation.
    ///
    /// The binary layout of this string is guaranteed, for now and all time, to be two bytes of little-endian length,
    /// followed by a contiguous array of bytes with that length, with no padding in between. This is intentionally
    /// identical to FixedList of byte, which is guaranteed to always have the same memory layout.
    ///
    /// Those who need more than 65,535 contiguous items should allocate from the heap, as storing that many things
    /// contiguously in a C# struct is likely to result in much wasted time, as the compiler copies the struct often.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Size=512)]
    public partial struct FixedString512
        : INativeList<byte>
        , IUTF8Bytes
        , IComparable<String>
        , IEquatable<String>
        , IComparable<FixedString32>
        , IEquatable<FixedString32>
        , IComparable<FixedString64>
        , IEquatable<FixedString64>
        , IComparable<FixedString128>
        , IEquatable<FixedString128>
        , IComparable<FixedString512>
        , IEquatable<FixedString512>
        , IComparable<FixedString4096>
        , IEquatable<FixedString4096>
    {
        internal const ushort utf8MaxLengthInBytes = 509;

        internal ushort utf8LengthInBytes;
        internal FixedBytes510 bytes;

        /// <summary>
        /// Returns the maximum number of utf8 bytes that can be stored in this type.
        /// </summary>
        public static int UTF8MaxLengthInBytes => utf8MaxLengthInBytes;

        /// <summary>
        /// A property in order to display the value in Unity.Properties generated UI.
        /// </summary>
        [CreateProperty]
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public string Value => ToString();

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe byte* GetUnsafePtr()
        {
            return (byte*) UnsafeUtility.AddressOf(ref bytes);
        }

        //
        // INativeList<byte> methods
        //

        /// <summary>
        /// The current length of the UTF-8 encoded string, in bytes.
        /// The string is guaranteed to he null-terminated.  The length value
        /// does not include the null terminating byte.
        /// </summary>
        public int Length
        {
            get
            {
                return utf8LengthInBytes;
            }
            set
            {
                CheckLengthInRange(value);
                utf8LengthInBytes = (ushort)value;
                unsafe
                {
                    GetUnsafePtr()[utf8LengthInBytes] = 0;
                }
            }
        }

        /// <summary>
        /// <undoc />
        /// </summary>
        [Obsolete("UTF8LengthInBytes has been renamed to just Length. (RemovedAfter 2020-08-01) (UnityUpgradable) -> Length", true)]
        public int UTF8LengthInBytes => Length;

        /// <summary>
        /// The maximum length of the UTF-8 encopded string, in bytes.
        /// Due to the UTF-8 encoding, each Unicode code point requires between 1 and 4 bytes to encode.
        /// The null terminating byte is not included in the capacity.  The FixedString always
        /// has space for a null terminating byte.
        /// </summary>
        public int Capacity
        {
            get
            {
                return utf8MaxLengthInBytes;
            }
            set
            {
                CheckCapacityInRange(value);
            }
        }

        /// <summary>
        /// Reports whether container is empty.
        /// </summary>
        /// <value>True if this container empty.</value>
        public bool IsEmpty => utf8LengthInBytes == 0;

        /// <summary>
        /// Return the byte at the given byte (not character) index.  The index
        /// must be in the range of [0..Length)
        /// </summary>
        public byte this[int index]
        {
            get
            {
                unsafe
                {
                    CheckIndexInRange(index);
                    return GetUnsafePtr()[index];
                }
            }

            set
            {
                unsafe
                {
                    CheckIndexInRange(index);
                    GetUnsafePtr()[index] = value;
                }
            }
        }

        /// <summary>
        /// Return a ref to the the byte at the given byte (not character) index.  The index
        /// must be in the range of [0..Length).  The ref byte is a direct reference into
        /// this FixedString, and is only valid while this FixedString is valid.
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public ref byte ElementAt(int index)
        {
            unsafe
            {
                CheckIndexInRange(index);
                return ref GetUnsafePtr()[index];
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public void Clear()
        {
            Length = 0;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="value"></param>
        public void Add(in byte value)
        {
            this[Length++] = value;
        }

        /// <summary>
        /// <undoc />
        /// </summary>
        public struct Enumerator : IEnumerator
        {
            FixedString512 target;
            int offset;
            Unicode.Rune current;

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <param name="other"><undoc /></param>
            public Enumerator(FixedString512 other)
            {
                target = other;
                offset = 0;
                current = default;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Dispose()
            {
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <returns><undoc /></returns>
            public bool MoveNext()
            {
                if (offset >= target.Length)
                    return false;

                unsafe
                {
                    Unicode.Utf8ToUcs(out current, target.GetUnsafePtr(), ref offset, target.Length);
                }

                return true;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Reset()
            {
                offset = 0;
                current = default;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public Unicode.Rune Current => current;

            object IEnumerator.Current => Current;
        }

        /// <summary>
        /// Returns an enumerator that iterates through a container.
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the container.</returns>
        public Enumerator GetEnumerator()
        {
            return new Enumerator(this);
        }

        /// <summary>
        /// Compare this FixedString512 with a System.String in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The System.String to compare with</param>
        /// <returns>
        /// -1 if this FixedString512 would appear first if sorted,
        ///  0 if they are identical, or
        ///  1 if the other System.String would appear first if sorted.
        /// </returns>
        public int CompareTo(String other)
        {
            return ToString().CompareTo(other);
        }

        /// <summary>
        /// Compare this FixedString512 with a System.String,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The System.String to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool Equals(String other)
        {
            return ToString().Equals(other);
        }

        /// <summary>
        /// Transform this struct to a reference to a FixedListByteN, which has the same layout.
        /// The returned reference is a reference to this data, and is only valid while it is valid.
        /// </summary>
        /// <returns></returns>
        public unsafe ref FixedListByte512 AsFixedList()
        {
            return ref UnsafeUtility.AsRef<FixedListByte512>(UnsafeUtility.AddressOf(ref this));
        }

        /// <summary>
        /// Construct a FixedString512 from a System.String object.
        /// </summary>
        /// <param name="source">The System.String object to construct this FixedString512 with</param>
        public FixedString512(String source)
        {
            bytes = default;
            utf8LengthInBytes = 0;
            unsafe
            {
                fixed (char* sourceptr = source)
                {
                    var error = UTF8ArrayUnsafeUtility.Copy(GetUnsafePtr(), out utf8LengthInBytes, utf8MaxLengthInBytes, sourceptr, source.Length);
                    if (error != CopyError.None)
                        throw new ArgumentException($"FixedString32: {error} while copying \"{source}\"");
                    this.Length = utf8LengthInBytes;
                }
            }
        }

        /// <summary>
        /// Compare this FixedString512 with a FixedString32 in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The FixedString to compare with</param>
        /// <returns>
        /// -1 if this FixedString512 would appear first if sorted,
        ///  0 if they are identical, or
        ///  1 if the other FixedString32 would appear first if sorted.
        /// </returns>
        public int CompareTo(FixedString32 other)
        {
            return FixedStringMethods.CompareTo(ref this, other);
        }

        /// <summary>
        /// Construct a FixedString512 by copying from another FixedString source.
        /// </summary>
        /// <param name="source"></param>
        public FixedString512(in FixedString32 source)
        {
            bytes = default;
            utf8LengthInBytes = 0;
            unsafe {
                int len = 0;
                byte* dstBytes = GetUnsafePtr();
                byte* srcBytes = (byte*) UnsafeUtilityExtensions.AddressOf(source.bytes);
                var srcLength = source.utf8LengthInBytes;
                if (UTF8ArrayUnsafeUtility.AppendUTF8Bytes(dstBytes, ref len, utf8MaxLengthInBytes, srcBytes, srcLength) != FormatError.None)
                    throw new ArgumentException("Source is too long to fit into fixed string of this size");
                this.Length = len;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator ==(in FixedString512 a, in FixedString32 b)
        {
            // this must not call any methods on 'a' or 'b'
            unsafe {
                int alen = a.utf8LengthInBytes;
                int blen = b.utf8LengthInBytes;
                byte* aptr = (byte*) UnsafeUtilityExtensions.AddressOf(a.bytes);
                byte* bptr = (byte*) UnsafeUtilityExtensions.AddressOf(b.bytes);
                return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aptr, alen, bptr, blen);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator !=(in FixedString512 a, in FixedString32 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(FixedString32 other)
        {
            return this == other;
        }

        /// <summary>
        /// Compare this FixedString512 with a FixedString64 in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The FixedString to compare with</param>
        /// <returns>
        /// -1 if this FixedString512 would appear first if sorted,
        ///  0 if they are identical, or
        ///  1 if the other FixedString64 would appear first if sorted.
        /// </returns>
        public int CompareTo(FixedString64 other)
        {
            return FixedStringMethods.CompareTo(ref this, other);
        }

        /// <summary>
        /// Construct a FixedString512 by copying from another FixedString source.
        /// </summary>
        /// <param name="source"></param>
        public FixedString512(in FixedString64 source)
        {
            bytes = default;
            utf8LengthInBytes = 0;
            unsafe {
                int len = 0;
                byte* dstBytes = GetUnsafePtr();
                byte* srcBytes = (byte*) UnsafeUtilityExtensions.AddressOf(source.bytes);
                var srcLength = source.utf8LengthInBytes;
                if (UTF8ArrayUnsafeUtility.AppendUTF8Bytes(dstBytes, ref len, utf8MaxLengthInBytes, srcBytes, srcLength) != FormatError.None)
                    throw new ArgumentException("Source is too long to fit into fixed string of this size");
                this.Length = len;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator ==(in FixedString512 a, in FixedString64 b)
        {
            // this must not call any methods on 'a' or 'b'
            unsafe {
                int alen = a.utf8LengthInBytes;
                int blen = b.utf8LengthInBytes;
                byte* aptr = (byte*) UnsafeUtilityExtensions.AddressOf(a.bytes);
                byte* bptr = (byte*) UnsafeUtilityExtensions.AddressOf(b.bytes);
                return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aptr, alen, bptr, blen);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator !=(in FixedString512 a, in FixedString64 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(FixedString64 other)
        {
            return this == other;
        }

        /// <summary>
        /// Compare this FixedString512 with a FixedString128 in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The FixedString to compare with</param>
        /// <returns>
        /// -1 if this FixedString512 would appear first if sorted,
        ///  0 if they are identical, or
        ///  1 if the other FixedString128 would appear first if sorted.
        /// </returns>
        public int CompareTo(FixedString128 other)
        {
            return FixedStringMethods.CompareTo(ref this, other);
        }

        /// <summary>
        /// Construct a FixedString512 by copying from another FixedString source.
        /// </summary>
        /// <param name="source"></param>
        public FixedString512(in FixedString128 source)
        {
            bytes = default;
            utf8LengthInBytes = 0;
            unsafe {
                int len = 0;
                byte* dstBytes = GetUnsafePtr();
                byte* srcBytes = (byte*) UnsafeUtilityExtensions.AddressOf(source.bytes);
                var srcLength = source.utf8LengthInBytes;
                if (UTF8ArrayUnsafeUtility.AppendUTF8Bytes(dstBytes, ref len, utf8MaxLengthInBytes, srcBytes, srcLength) != FormatError.None)
                    throw new ArgumentException("Source is too long to fit into fixed string of this size");
                this.Length = len;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator ==(in FixedString512 a, in FixedString128 b)
        {
            // this must not call any methods on 'a' or 'b'
            unsafe {
                int alen = a.utf8LengthInBytes;
                int blen = b.utf8LengthInBytes;
                byte* aptr = (byte*) UnsafeUtilityExtensions.AddressOf(a.bytes);
                byte* bptr = (byte*) UnsafeUtilityExtensions.AddressOf(b.bytes);
                return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aptr, alen, bptr, blen);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator !=(in FixedString512 a, in FixedString128 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(FixedString128 other)
        {
            return this == other;
        }

        /// <summary>
        /// Compare this FixedString512 with a FixedString512 in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The FixedString to compare with</param>
        /// <returns>
        /// -1 if this FixedString512 would appear first if sorted,
        ///  0 if they are identical, or
        ///  1 if the other FixedString512 would appear first if sorted.
        /// </returns>
        public int CompareTo(FixedString512 other)
        {
            return FixedStringMethods.CompareTo(ref this, other);
        }

        /// <summary>
        /// Construct a FixedString512 by copying from another FixedString source.
        /// </summary>
        /// <param name="source"></param>
        public FixedString512(in FixedString512 source)
        {
            bytes = default;
            utf8LengthInBytes = 0;
            unsafe {
                int len = 0;
                byte* dstBytes = GetUnsafePtr();
                byte* srcBytes = (byte*) UnsafeUtilityExtensions.AddressOf(source.bytes);
                var srcLength = source.utf8LengthInBytes;
                if (UTF8ArrayUnsafeUtility.AppendUTF8Bytes(dstBytes, ref len, utf8MaxLengthInBytes, srcBytes, srcLength) != FormatError.None)
                    throw new ArgumentException("Source is too long to fit into fixed string of this size");
                this.Length = len;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator ==(in FixedString512 a, in FixedString512 b)
        {
            // this must not call any methods on 'a' or 'b'
            unsafe {
                int alen = a.utf8LengthInBytes;
                int blen = b.utf8LengthInBytes;
                byte* aptr = (byte*) UnsafeUtilityExtensions.AddressOf(a.bytes);
                byte* bptr = (byte*) UnsafeUtilityExtensions.AddressOf(b.bytes);
                return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aptr, alen, bptr, blen);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator !=(in FixedString512 a, in FixedString512 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(FixedString512 other)
        {
            return this == other;
        }

        /// <summary>
        /// Compare this FixedString512 with a FixedString4096 in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The FixedString to compare with</param>
        /// <returns>
        /// -1 if this FixedString512 would appear first if sorted,
        ///  0 if they are identical, or
        ///  1 if the other FixedString4096 would appear first if sorted.
        /// </returns>
        public int CompareTo(FixedString4096 other)
        {
            return FixedStringMethods.CompareTo(ref this, other);
        }

        /// <summary>
        /// Construct a FixedString512 by copying from another FixedString source.
        /// </summary>
        /// <param name="source"></param>
        public FixedString512(in FixedString4096 source)
        {
            bytes = default;
            utf8LengthInBytes = 0;
            unsafe {
                int len = 0;
                byte* dstBytes = GetUnsafePtr();
                byte* srcBytes = (byte*) UnsafeUtilityExtensions.AddressOf(source.bytes);
                var srcLength = source.utf8LengthInBytes;
                if (UTF8ArrayUnsafeUtility.AppendUTF8Bytes(dstBytes, ref len, utf8MaxLengthInBytes, srcBytes, srcLength) != FormatError.None)
                    throw new ArgumentException("Source is too long to fit into fixed string of this size");
                this.Length = len;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator ==(in FixedString512 a, in FixedString4096 b)
        {
            // this must not call any methods on 'a' or 'b'
            unsafe {
                int alen = a.utf8LengthInBytes;
                int blen = b.utf8LengthInBytes;
                byte* aptr = (byte*) UnsafeUtilityExtensions.AddressOf(a.bytes);
                byte* bptr = (byte*) UnsafeUtilityExtensions.AddressOf(b.bytes);
                return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aptr, alen, bptr, blen);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator !=(in FixedString512 a, in FixedString4096 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(FixedString4096 other)
        {
            return this == other;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="fs"></param>
        /// <returns></returns>
        public static implicit operator FixedString4096(in FixedString512 fs) => new FixedString4096(in fs);

        /// <summary>
        /// Enable implicit conversion of System.String to FixedString512.
        /// </summary>
        /// <param name="b">The System.String object to convert to a FixedString512</param>
        /// <returns></returns>
        public static implicit operator FixedString512(string b) => new FixedString512(b);

        /// <summary>
        /// Convert this FixedString512 to a System.String.
        /// </summary>
        /// <returns>A System.String with a copy of this FixedString512</returns>
        public override String ToString()
        {
            return this.ConvertToString();
        }

        /// <summary>
        /// Compute a hash code of this FixedString512: an integer that is likely to be different for
        /// two FixedString512, if their contents are different.
        /// </summary>
        /// <returns>A hash code of this FixedString512</returns>
        public override int GetHashCode()
        {
            return this.ComputeHashCode();
        }

        /// <summary>
        /// Determines whether a FixedString512 has the same value as some other object.
        /// </summary>
        /// <param name="obj">The object to compare for equality</param>
        /// <returns></returns>
        public override bool Equals(object obj)
        {
            if(ReferenceEquals(null, obj)) return false;
            if(obj is String aString) return Equals(aString);
            if(obj is FixedString32 aFixedString32) return Equals(aFixedString32);
            if(obj is FixedString64 aFixedString64) return Equals(aFixedString64);
            if(obj is FixedString128 aFixedString128) return Equals(aFixedString128);
            if(obj is FixedString512 aFixedString512) return Equals(aFixedString512);
            if(obj is FixedString4096 aFixedString4096) return Equals(aFixedString4096);
            return false;
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        void CheckIndexInRange(int index)
        {
            if (index < 0)
                throw new IndexOutOfRangeException($"Index {index} must be positive.");
            if (index >= utf8LengthInBytes)
                throw new IndexOutOfRangeException($"Index {index} is out of range in FixedString512 of '{utf8LengthInBytes}' Length.");
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        void CheckLengthInRange(int length)
        {
            if (length < 0)
                throw new ArgumentOutOfRangeException($"Length {length} must be positive.");
            if (length > utf8MaxLengthInBytes)
                throw new ArgumentOutOfRangeException($"Length {length} is out of range in FixedString512 of '{utf8MaxLengthInBytes}' Capacity.");
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        void CheckCapacityInRange(int capacity)
        {
            if (capacity != Capacity)
                throw new ArgumentOutOfRangeException($"Capacity {capacity} must be {Capacity}.");
        }
    }

    [StructLayout(LayoutKind.Explicit, Size=4094)]
    internal struct FixedBytes4094
    {
        [FieldOffset(0)] internal FixedBytes16 offset0000;
        [FieldOffset(16)] internal FixedBytes16 offset0016;
        [FieldOffset(32)] internal FixedBytes16 offset0032;
        [FieldOffset(48)] internal FixedBytes16 offset0048;
        [FieldOffset(64)] internal FixedBytes16 offset0064;
        [FieldOffset(80)] internal FixedBytes16 offset0080;
        [FieldOffset(96)] internal FixedBytes16 offset0096;
        [FieldOffset(112)] internal FixedBytes16 offset0112;
        [FieldOffset(128)] internal FixedBytes16 offset0128;
        [FieldOffset(144)] internal FixedBytes16 offset0144;
        [FieldOffset(160)] internal FixedBytes16 offset0160;
        [FieldOffset(176)] internal FixedBytes16 offset0176;
        [FieldOffset(192)] internal FixedBytes16 offset0192;
        [FieldOffset(208)] internal FixedBytes16 offset0208;
        [FieldOffset(224)] internal FixedBytes16 offset0224;
        [FieldOffset(240)] internal FixedBytes16 offset0240;
        [FieldOffset(256)] internal FixedBytes16 offset0256;
        [FieldOffset(272)] internal FixedBytes16 offset0272;
        [FieldOffset(288)] internal FixedBytes16 offset0288;
        [FieldOffset(304)] internal FixedBytes16 offset0304;
        [FieldOffset(320)] internal FixedBytes16 offset0320;
        [FieldOffset(336)] internal FixedBytes16 offset0336;
        [FieldOffset(352)] internal FixedBytes16 offset0352;
        [FieldOffset(368)] internal FixedBytes16 offset0368;
        [FieldOffset(384)] internal FixedBytes16 offset0384;
        [FieldOffset(400)] internal FixedBytes16 offset0400;
        [FieldOffset(416)] internal FixedBytes16 offset0416;
        [FieldOffset(432)] internal FixedBytes16 offset0432;
        [FieldOffset(448)] internal FixedBytes16 offset0448;
        [FieldOffset(464)] internal FixedBytes16 offset0464;
        [FieldOffset(480)] internal FixedBytes16 offset0480;
        [FieldOffset(496)] internal FixedBytes16 offset0496;
        [FieldOffset(512)] internal FixedBytes16 offset0512;
        [FieldOffset(528)] internal FixedBytes16 offset0528;
        [FieldOffset(544)] internal FixedBytes16 offset0544;
        [FieldOffset(560)] internal FixedBytes16 offset0560;
        [FieldOffset(576)] internal FixedBytes16 offset0576;
        [FieldOffset(592)] internal FixedBytes16 offset0592;
        [FieldOffset(608)] internal FixedBytes16 offset0608;
        [FieldOffset(624)] internal FixedBytes16 offset0624;
        [FieldOffset(640)] internal FixedBytes16 offset0640;
        [FieldOffset(656)] internal FixedBytes16 offset0656;
        [FieldOffset(672)] internal FixedBytes16 offset0672;
        [FieldOffset(688)] internal FixedBytes16 offset0688;
        [FieldOffset(704)] internal FixedBytes16 offset0704;
        [FieldOffset(720)] internal FixedBytes16 offset0720;
        [FieldOffset(736)] internal FixedBytes16 offset0736;
        [FieldOffset(752)] internal FixedBytes16 offset0752;
        [FieldOffset(768)] internal FixedBytes16 offset0768;
        [FieldOffset(784)] internal FixedBytes16 offset0784;
        [FieldOffset(800)] internal FixedBytes16 offset0800;
        [FieldOffset(816)] internal FixedBytes16 offset0816;
        [FieldOffset(832)] internal FixedBytes16 offset0832;
        [FieldOffset(848)] internal FixedBytes16 offset0848;
        [FieldOffset(864)] internal FixedBytes16 offset0864;
        [FieldOffset(880)] internal FixedBytes16 offset0880;
        [FieldOffset(896)] internal FixedBytes16 offset0896;
        [FieldOffset(912)] internal FixedBytes16 offset0912;
        [FieldOffset(928)] internal FixedBytes16 offset0928;
        [FieldOffset(944)] internal FixedBytes16 offset0944;
        [FieldOffset(960)] internal FixedBytes16 offset0960;
        [FieldOffset(976)] internal FixedBytes16 offset0976;
        [FieldOffset(992)] internal FixedBytes16 offset0992;
        [FieldOffset(1008)] internal FixedBytes16 offset1008;
        [FieldOffset(1024)] internal FixedBytes16 offset1024;
        [FieldOffset(1040)] internal FixedBytes16 offset1040;
        [FieldOffset(1056)] internal FixedBytes16 offset1056;
        [FieldOffset(1072)] internal FixedBytes16 offset1072;
        [FieldOffset(1088)] internal FixedBytes16 offset1088;
        [FieldOffset(1104)] internal FixedBytes16 offset1104;
        [FieldOffset(1120)] internal FixedBytes16 offset1120;
        [FieldOffset(1136)] internal FixedBytes16 offset1136;
        [FieldOffset(1152)] internal FixedBytes16 offset1152;
        [FieldOffset(1168)] internal FixedBytes16 offset1168;
        [FieldOffset(1184)] internal FixedBytes16 offset1184;
        [FieldOffset(1200)] internal FixedBytes16 offset1200;
        [FieldOffset(1216)] internal FixedBytes16 offset1216;
        [FieldOffset(1232)] internal FixedBytes16 offset1232;
        [FieldOffset(1248)] internal FixedBytes16 offset1248;
        [FieldOffset(1264)] internal FixedBytes16 offset1264;
        [FieldOffset(1280)] internal FixedBytes16 offset1280;
        [FieldOffset(1296)] internal FixedBytes16 offset1296;
        [FieldOffset(1312)] internal FixedBytes16 offset1312;
        [FieldOffset(1328)] internal FixedBytes16 offset1328;
        [FieldOffset(1344)] internal FixedBytes16 offset1344;
        [FieldOffset(1360)] internal FixedBytes16 offset1360;
        [FieldOffset(1376)] internal FixedBytes16 offset1376;
        [FieldOffset(1392)] internal FixedBytes16 offset1392;
        [FieldOffset(1408)] internal FixedBytes16 offset1408;
        [FieldOffset(1424)] internal FixedBytes16 offset1424;
        [FieldOffset(1440)] internal FixedBytes16 offset1440;
        [FieldOffset(1456)] internal FixedBytes16 offset1456;
        [FieldOffset(1472)] internal FixedBytes16 offset1472;
        [FieldOffset(1488)] internal FixedBytes16 offset1488;
        [FieldOffset(1504)] internal FixedBytes16 offset1504;
        [FieldOffset(1520)] internal FixedBytes16 offset1520;
        [FieldOffset(1536)] internal FixedBytes16 offset1536;
        [FieldOffset(1552)] internal FixedBytes16 offset1552;
        [FieldOffset(1568)] internal FixedBytes16 offset1568;
        [FieldOffset(1584)] internal FixedBytes16 offset1584;
        [FieldOffset(1600)] internal FixedBytes16 offset1600;
        [FieldOffset(1616)] internal FixedBytes16 offset1616;
        [FieldOffset(1632)] internal FixedBytes16 offset1632;
        [FieldOffset(1648)] internal FixedBytes16 offset1648;
        [FieldOffset(1664)] internal FixedBytes16 offset1664;
        [FieldOffset(1680)] internal FixedBytes16 offset1680;
        [FieldOffset(1696)] internal FixedBytes16 offset1696;
        [FieldOffset(1712)] internal FixedBytes16 offset1712;
        [FieldOffset(1728)] internal FixedBytes16 offset1728;
        [FieldOffset(1744)] internal FixedBytes16 offset1744;
        [FieldOffset(1760)] internal FixedBytes16 offset1760;
        [FieldOffset(1776)] internal FixedBytes16 offset1776;
        [FieldOffset(1792)] internal FixedBytes16 offset1792;
        [FieldOffset(1808)] internal FixedBytes16 offset1808;
        [FieldOffset(1824)] internal FixedBytes16 offset1824;
        [FieldOffset(1840)] internal FixedBytes16 offset1840;
        [FieldOffset(1856)] internal FixedBytes16 offset1856;
        [FieldOffset(1872)] internal FixedBytes16 offset1872;
        [FieldOffset(1888)] internal FixedBytes16 offset1888;
        [FieldOffset(1904)] internal FixedBytes16 offset1904;
        [FieldOffset(1920)] internal FixedBytes16 offset1920;
        [FieldOffset(1936)] internal FixedBytes16 offset1936;
        [FieldOffset(1952)] internal FixedBytes16 offset1952;
        [FieldOffset(1968)] internal FixedBytes16 offset1968;
        [FieldOffset(1984)] internal FixedBytes16 offset1984;
        [FieldOffset(2000)] internal FixedBytes16 offset2000;
        [FieldOffset(2016)] internal FixedBytes16 offset2016;
        [FieldOffset(2032)] internal FixedBytes16 offset2032;
        [FieldOffset(2048)] internal FixedBytes16 offset2048;
        [FieldOffset(2064)] internal FixedBytes16 offset2064;
        [FieldOffset(2080)] internal FixedBytes16 offset2080;
        [FieldOffset(2096)] internal FixedBytes16 offset2096;
        [FieldOffset(2112)] internal FixedBytes16 offset2112;
        [FieldOffset(2128)] internal FixedBytes16 offset2128;
        [FieldOffset(2144)] internal FixedBytes16 offset2144;
        [FieldOffset(2160)] internal FixedBytes16 offset2160;
        [FieldOffset(2176)] internal FixedBytes16 offset2176;
        [FieldOffset(2192)] internal FixedBytes16 offset2192;
        [FieldOffset(2208)] internal FixedBytes16 offset2208;
        [FieldOffset(2224)] internal FixedBytes16 offset2224;
        [FieldOffset(2240)] internal FixedBytes16 offset2240;
        [FieldOffset(2256)] internal FixedBytes16 offset2256;
        [FieldOffset(2272)] internal FixedBytes16 offset2272;
        [FieldOffset(2288)] internal FixedBytes16 offset2288;
        [FieldOffset(2304)] internal FixedBytes16 offset2304;
        [FieldOffset(2320)] internal FixedBytes16 offset2320;
        [FieldOffset(2336)] internal FixedBytes16 offset2336;
        [FieldOffset(2352)] internal FixedBytes16 offset2352;
        [FieldOffset(2368)] internal FixedBytes16 offset2368;
        [FieldOffset(2384)] internal FixedBytes16 offset2384;
        [FieldOffset(2400)] internal FixedBytes16 offset2400;
        [FieldOffset(2416)] internal FixedBytes16 offset2416;
        [FieldOffset(2432)] internal FixedBytes16 offset2432;
        [FieldOffset(2448)] internal FixedBytes16 offset2448;
        [FieldOffset(2464)] internal FixedBytes16 offset2464;
        [FieldOffset(2480)] internal FixedBytes16 offset2480;
        [FieldOffset(2496)] internal FixedBytes16 offset2496;
        [FieldOffset(2512)] internal FixedBytes16 offset2512;
        [FieldOffset(2528)] internal FixedBytes16 offset2528;
        [FieldOffset(2544)] internal FixedBytes16 offset2544;
        [FieldOffset(2560)] internal FixedBytes16 offset2560;
        [FieldOffset(2576)] internal FixedBytes16 offset2576;
        [FieldOffset(2592)] internal FixedBytes16 offset2592;
        [FieldOffset(2608)] internal FixedBytes16 offset2608;
        [FieldOffset(2624)] internal FixedBytes16 offset2624;
        [FieldOffset(2640)] internal FixedBytes16 offset2640;
        [FieldOffset(2656)] internal FixedBytes16 offset2656;
        [FieldOffset(2672)] internal FixedBytes16 offset2672;
        [FieldOffset(2688)] internal FixedBytes16 offset2688;
        [FieldOffset(2704)] internal FixedBytes16 offset2704;
        [FieldOffset(2720)] internal FixedBytes16 offset2720;
        [FieldOffset(2736)] internal FixedBytes16 offset2736;
        [FieldOffset(2752)] internal FixedBytes16 offset2752;
        [FieldOffset(2768)] internal FixedBytes16 offset2768;
        [FieldOffset(2784)] internal FixedBytes16 offset2784;
        [FieldOffset(2800)] internal FixedBytes16 offset2800;
        [FieldOffset(2816)] internal FixedBytes16 offset2816;
        [FieldOffset(2832)] internal FixedBytes16 offset2832;
        [FieldOffset(2848)] internal FixedBytes16 offset2848;
        [FieldOffset(2864)] internal FixedBytes16 offset2864;
        [FieldOffset(2880)] internal FixedBytes16 offset2880;
        [FieldOffset(2896)] internal FixedBytes16 offset2896;
        [FieldOffset(2912)] internal FixedBytes16 offset2912;
        [FieldOffset(2928)] internal FixedBytes16 offset2928;
        [FieldOffset(2944)] internal FixedBytes16 offset2944;
        [FieldOffset(2960)] internal FixedBytes16 offset2960;
        [FieldOffset(2976)] internal FixedBytes16 offset2976;
        [FieldOffset(2992)] internal FixedBytes16 offset2992;
        [FieldOffset(3008)] internal FixedBytes16 offset3008;
        [FieldOffset(3024)] internal FixedBytes16 offset3024;
        [FieldOffset(3040)] internal FixedBytes16 offset3040;
        [FieldOffset(3056)] internal FixedBytes16 offset3056;
        [FieldOffset(3072)] internal FixedBytes16 offset3072;
        [FieldOffset(3088)] internal FixedBytes16 offset3088;
        [FieldOffset(3104)] internal FixedBytes16 offset3104;
        [FieldOffset(3120)] internal FixedBytes16 offset3120;
        [FieldOffset(3136)] internal FixedBytes16 offset3136;
        [FieldOffset(3152)] internal FixedBytes16 offset3152;
        [FieldOffset(3168)] internal FixedBytes16 offset3168;
        [FieldOffset(3184)] internal FixedBytes16 offset3184;
        [FieldOffset(3200)] internal FixedBytes16 offset3200;
        [FieldOffset(3216)] internal FixedBytes16 offset3216;
        [FieldOffset(3232)] internal FixedBytes16 offset3232;
        [FieldOffset(3248)] internal FixedBytes16 offset3248;
        [FieldOffset(3264)] internal FixedBytes16 offset3264;
        [FieldOffset(3280)] internal FixedBytes16 offset3280;
        [FieldOffset(3296)] internal FixedBytes16 offset3296;
        [FieldOffset(3312)] internal FixedBytes16 offset3312;
        [FieldOffset(3328)] internal FixedBytes16 offset3328;
        [FieldOffset(3344)] internal FixedBytes16 offset3344;
        [FieldOffset(3360)] internal FixedBytes16 offset3360;
        [FieldOffset(3376)] internal FixedBytes16 offset3376;
        [FieldOffset(3392)] internal FixedBytes16 offset3392;
        [FieldOffset(3408)] internal FixedBytes16 offset3408;
        [FieldOffset(3424)] internal FixedBytes16 offset3424;
        [FieldOffset(3440)] internal FixedBytes16 offset3440;
        [FieldOffset(3456)] internal FixedBytes16 offset3456;
        [FieldOffset(3472)] internal FixedBytes16 offset3472;
        [FieldOffset(3488)] internal FixedBytes16 offset3488;
        [FieldOffset(3504)] internal FixedBytes16 offset3504;
        [FieldOffset(3520)] internal FixedBytes16 offset3520;
        [FieldOffset(3536)] internal FixedBytes16 offset3536;
        [FieldOffset(3552)] internal FixedBytes16 offset3552;
        [FieldOffset(3568)] internal FixedBytes16 offset3568;
        [FieldOffset(3584)] internal FixedBytes16 offset3584;
        [FieldOffset(3600)] internal FixedBytes16 offset3600;
        [FieldOffset(3616)] internal FixedBytes16 offset3616;
        [FieldOffset(3632)] internal FixedBytes16 offset3632;
        [FieldOffset(3648)] internal FixedBytes16 offset3648;
        [FieldOffset(3664)] internal FixedBytes16 offset3664;
        [FieldOffset(3680)] internal FixedBytes16 offset3680;
        [FieldOffset(3696)] internal FixedBytes16 offset3696;
        [FieldOffset(3712)] internal FixedBytes16 offset3712;
        [FieldOffset(3728)] internal FixedBytes16 offset3728;
        [FieldOffset(3744)] internal FixedBytes16 offset3744;
        [FieldOffset(3760)] internal FixedBytes16 offset3760;
        [FieldOffset(3776)] internal FixedBytes16 offset3776;
        [FieldOffset(3792)] internal FixedBytes16 offset3792;
        [FieldOffset(3808)] internal FixedBytes16 offset3808;
        [FieldOffset(3824)] internal FixedBytes16 offset3824;
        [FieldOffset(3840)] internal FixedBytes16 offset3840;
        [FieldOffset(3856)] internal FixedBytes16 offset3856;
        [FieldOffset(3872)] internal FixedBytes16 offset3872;
        [FieldOffset(3888)] internal FixedBytes16 offset3888;
        [FieldOffset(3904)] internal FixedBytes16 offset3904;
        [FieldOffset(3920)] internal FixedBytes16 offset3920;
        [FieldOffset(3936)] internal FixedBytes16 offset3936;
        [FieldOffset(3952)] internal FixedBytes16 offset3952;
        [FieldOffset(3968)] internal FixedBytes16 offset3968;
        [FieldOffset(3984)] internal FixedBytes16 offset3984;
        [FieldOffset(4000)] internal FixedBytes16 offset4000;
        [FieldOffset(4016)] internal FixedBytes16 offset4016;
        [FieldOffset(4032)] internal FixedBytes16 offset4032;
        [FieldOffset(4048)] internal FixedBytes16 offset4048;
        [FieldOffset(4064)] internal FixedBytes16 offset4064;
        [FieldOffset(4080)] internal byte byte4080;
        [FieldOffset(4081)] internal byte byte4081;
        [FieldOffset(4082)] internal byte byte4082;
        [FieldOffset(4083)] internal byte byte4083;
        [FieldOffset(4084)] internal byte byte4084;
        [FieldOffset(4085)] internal byte byte4085;
        [FieldOffset(4086)] internal byte byte4086;
        [FieldOffset(4087)] internal byte byte4087;
        [FieldOffset(4088)] internal byte byte4088;
        [FieldOffset(4089)] internal byte byte4089;
        [FieldOffset(4090)] internal byte byte4090;
        [FieldOffset(4091)] internal byte byte4091;
        [FieldOffset(4092)] internal byte byte4092;
        [FieldOffset(4093)] internal byte byte4093;
    }

    /// <summary>
    /// An unmanaged string in UTF-8 format that contains its own fixed-size buffer of the given size in bytes.
    /// The string is NOT guaranteed to be null-terminated, though in many cases it may be by accident.
    /// No memory is ever allocated, and no attempt is made to share memory when strings are copied.
    /// Since this structure is not generic and needs no disposing, it can exist inside ECS components,
    /// can be put in a FixedArray, FixedList or FixedHashMap, and can be a data member of unmanaged structs
    /// that are allocated from the unmanaged heap. This string is entirely compatible with Burst compilation.
    ///
    /// The binary layout of this string is guaranteed, for now and all time, to be two bytes of little-endian length,
    /// followed by a contiguous array of bytes with that length, with no padding in between. This is intentionally
    /// identical to FixedList of byte, which is guaranteed to always have the same memory layout.
    ///
    /// Those who need more than 65,535 contiguous items should allocate from the heap, as storing that many things
    /// contiguously in a C# struct is likely to result in much wasted time, as the compiler copies the struct often.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Size=4096)]
    public partial struct FixedString4096
        : INativeList<byte>
        , IUTF8Bytes
        , IComparable<String>
        , IEquatable<String>
        , IComparable<FixedString32>
        , IEquatable<FixedString32>
        , IComparable<FixedString64>
        , IEquatable<FixedString64>
        , IComparable<FixedString128>
        , IEquatable<FixedString128>
        , IComparable<FixedString512>
        , IEquatable<FixedString512>
        , IComparable<FixedString4096>
        , IEquatable<FixedString4096>
    {
        internal const ushort utf8MaxLengthInBytes = 4093;

        internal ushort utf8LengthInBytes;
        internal FixedBytes4094 bytes;

        /// <summary>
        /// Returns the maximum number of utf8 bytes that can be stored in this type.
        /// </summary>
        public static int UTF8MaxLengthInBytes => utf8MaxLengthInBytes;

        /// <summary>
        /// A property in order to display the value in Unity.Properties generated UI.
        /// </summary>
        [CreateProperty]
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public string Value => ToString();

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe byte* GetUnsafePtr()
        {
            return (byte*) UnsafeUtility.AddressOf(ref bytes);
        }

        //
        // INativeList<byte> methods
        //

        /// <summary>
        /// The current length of the UTF-8 encoded string, in bytes.
        /// The string is guaranteed to he null-terminated.  The length value
        /// does not include the null terminating byte.
        /// </summary>
        public int Length
        {
            get
            {
                return utf8LengthInBytes;
            }
            set
            {
                CheckLengthInRange(value);
                utf8LengthInBytes = (ushort)value;
                unsafe
                {
                    GetUnsafePtr()[utf8LengthInBytes] = 0;
                }
            }
        }

        /// <summary>
        /// <undoc />
        /// </summary>
        [Obsolete("UTF8LengthInBytes has been renamed to just Length. (RemovedAfter 2020-08-01) (UnityUpgradable) -> Length", true)]
        public int UTF8LengthInBytes => Length;

        /// <summary>
        /// The maximum length of the UTF-8 encopded string, in bytes.
        /// Due to the UTF-8 encoding, each Unicode code point requires between 1 and 4 bytes to encode.
        /// The null terminating byte is not included in the capacity.  The FixedString always
        /// has space for a null terminating byte.
        /// </summary>
        public int Capacity
        {
            get
            {
                return utf8MaxLengthInBytes;
            }
            set
            {
                CheckCapacityInRange(value);
            }
        }

        /// <summary>
        /// Reports whether container is empty.
        /// </summary>
        /// <value>True if this container empty.</value>
        public bool IsEmpty => utf8LengthInBytes == 0;

        /// <summary>
        /// Return the byte at the given byte (not character) index.  The index
        /// must be in the range of [0..Length)
        /// </summary>
        public byte this[int index]
        {
            get
            {
                unsafe
                {
                    CheckIndexInRange(index);
                    return GetUnsafePtr()[index];
                }
            }

            set
            {
                unsafe
                {
                    CheckIndexInRange(index);
                    GetUnsafePtr()[index] = value;
                }
            }
        }

        /// <summary>
        /// Return a ref to the the byte at the given byte (not character) index.  The index
        /// must be in the range of [0..Length).  The ref byte is a direct reference into
        /// this FixedString, and is only valid while this FixedString is valid.
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public ref byte ElementAt(int index)
        {
            unsafe
            {
                CheckIndexInRange(index);
                return ref GetUnsafePtr()[index];
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public void Clear()
        {
            Length = 0;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="value"></param>
        public void Add(in byte value)
        {
            this[Length++] = value;
        }

        /// <summary>
        /// <undoc />
        /// </summary>
        public struct Enumerator : IEnumerator
        {
            FixedString4096 target;
            int offset;
            Unicode.Rune current;

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <param name="other"><undoc /></param>
            public Enumerator(FixedString4096 other)
            {
                target = other;
                offset = 0;
                current = default;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Dispose()
            {
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <returns><undoc /></returns>
            public bool MoveNext()
            {
                if (offset >= target.Length)
                    return false;

                unsafe
                {
                    Unicode.Utf8ToUcs(out current, target.GetUnsafePtr(), ref offset, target.Length);
                }

                return true;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Reset()
            {
                offset = 0;
                current = default;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public Unicode.Rune Current => current;

            object IEnumerator.Current => Current;
        }

        /// <summary>
        /// Returns an enumerator that iterates through a container.
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the container.</returns>
        public Enumerator GetEnumerator()
        {
            return new Enumerator(this);
        }

        /// <summary>
        /// Compare this FixedString4096 with a System.String in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The System.String to compare with</param>
        /// <returns>
        /// -1 if this FixedString4096 would appear first if sorted,
        ///  0 if they are identical, or
        ///  1 if the other System.String would appear first if sorted.
        /// </returns>
        public int CompareTo(String other)
        {
            return ToString().CompareTo(other);
        }

        /// <summary>
        /// Compare this FixedString4096 with a System.String,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The System.String to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool Equals(String other)
        {
            return ToString().Equals(other);
        }

        /// <summary>
        /// Transform this struct to a reference to a FixedListByteN, which has the same layout.
        /// The returned reference is a reference to this data, and is only valid while it is valid.
        /// </summary>
        /// <returns></returns>
        public unsafe ref FixedListByte4096 AsFixedList()
        {
            return ref UnsafeUtility.AsRef<FixedListByte4096>(UnsafeUtility.AddressOf(ref this));
        }

        /// <summary>
        /// Construct a FixedString4096 from a System.String object.
        /// </summary>
        /// <param name="source">The System.String object to construct this FixedString4096 with</param>
        public FixedString4096(String source)
        {
            bytes = default;
            utf8LengthInBytes = 0;
            unsafe
            {
                fixed (char* sourceptr = source)
                {
                    var error = UTF8ArrayUnsafeUtility.Copy(GetUnsafePtr(), out utf8LengthInBytes, utf8MaxLengthInBytes, sourceptr, source.Length);
                    if (error != CopyError.None)
                        throw new ArgumentException($"FixedString32: {error} while copying \"{source}\"");
                    this.Length = utf8LengthInBytes;
                }
            }
        }

        /// <summary>
        /// Compare this FixedString4096 with a FixedString32 in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The FixedString to compare with</param>
        /// <returns>
        /// -1 if this FixedString4096 would appear first if sorted,
        ///  0 if they are identical, or
        ///  1 if the other FixedString32 would appear first if sorted.
        /// </returns>
        public int CompareTo(FixedString32 other)
        {
            return FixedStringMethods.CompareTo(ref this, other);
        }

        /// <summary>
        /// Construct a FixedString4096 by copying from another FixedString source.
        /// </summary>
        /// <param name="source"></param>
        public FixedString4096(in FixedString32 source)
        {
            bytes = default;
            utf8LengthInBytes = 0;
            unsafe {
                int len = 0;
                byte* dstBytes = GetUnsafePtr();
                byte* srcBytes = (byte*) UnsafeUtilityExtensions.AddressOf(source.bytes);
                var srcLength = source.utf8LengthInBytes;
                if (UTF8ArrayUnsafeUtility.AppendUTF8Bytes(dstBytes, ref len, utf8MaxLengthInBytes, srcBytes, srcLength) != FormatError.None)
                    throw new ArgumentException("Source is too long to fit into fixed string of this size");
                this.Length = len;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator ==(in FixedString4096 a, in FixedString32 b)
        {
            // this must not call any methods on 'a' or 'b'
            unsafe {
                int alen = a.utf8LengthInBytes;
                int blen = b.utf8LengthInBytes;
                byte* aptr = (byte*) UnsafeUtilityExtensions.AddressOf(a.bytes);
                byte* bptr = (byte*) UnsafeUtilityExtensions.AddressOf(b.bytes);
                return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aptr, alen, bptr, blen);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator !=(in FixedString4096 a, in FixedString32 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(FixedString32 other)
        {
            return this == other;
        }

        /// <summary>
        /// Compare this FixedString4096 with a FixedString64 in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The FixedString to compare with</param>
        /// <returns>
        /// -1 if this FixedString4096 would appear first if sorted,
        ///  0 if they are identical, or
        ///  1 if the other FixedString64 would appear first if sorted.
        /// </returns>
        public int CompareTo(FixedString64 other)
        {
            return FixedStringMethods.CompareTo(ref this, other);
        }

        /// <summary>
        /// Construct a FixedString4096 by copying from another FixedString source.
        /// </summary>
        /// <param name="source"></param>
        public FixedString4096(in FixedString64 source)
        {
            bytes = default;
            utf8LengthInBytes = 0;
            unsafe {
                int len = 0;
                byte* dstBytes = GetUnsafePtr();
                byte* srcBytes = (byte*) UnsafeUtilityExtensions.AddressOf(source.bytes);
                var srcLength = source.utf8LengthInBytes;
                if (UTF8ArrayUnsafeUtility.AppendUTF8Bytes(dstBytes, ref len, utf8MaxLengthInBytes, srcBytes, srcLength) != FormatError.None)
                    throw new ArgumentException("Source is too long to fit into fixed string of this size");
                this.Length = len;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator ==(in FixedString4096 a, in FixedString64 b)
        {
            // this must not call any methods on 'a' or 'b'
            unsafe {
                int alen = a.utf8LengthInBytes;
                int blen = b.utf8LengthInBytes;
                byte* aptr = (byte*) UnsafeUtilityExtensions.AddressOf(a.bytes);
                byte* bptr = (byte*) UnsafeUtilityExtensions.AddressOf(b.bytes);
                return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aptr, alen, bptr, blen);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator !=(in FixedString4096 a, in FixedString64 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(FixedString64 other)
        {
            return this == other;
        }

        /// <summary>
        /// Compare this FixedString4096 with a FixedString128 in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The FixedString to compare with</param>
        /// <returns>
        /// -1 if this FixedString4096 would appear first if sorted,
        ///  0 if they are identical, or
        ///  1 if the other FixedString128 would appear first if sorted.
        /// </returns>
        public int CompareTo(FixedString128 other)
        {
            return FixedStringMethods.CompareTo(ref this, other);
        }

        /// <summary>
        /// Construct a FixedString4096 by copying from another FixedString source.
        /// </summary>
        /// <param name="source"></param>
        public FixedString4096(in FixedString128 source)
        {
            bytes = default;
            utf8LengthInBytes = 0;
            unsafe {
                int len = 0;
                byte* dstBytes = GetUnsafePtr();
                byte* srcBytes = (byte*) UnsafeUtilityExtensions.AddressOf(source.bytes);
                var srcLength = source.utf8LengthInBytes;
                if (UTF8ArrayUnsafeUtility.AppendUTF8Bytes(dstBytes, ref len, utf8MaxLengthInBytes, srcBytes, srcLength) != FormatError.None)
                    throw new ArgumentException("Source is too long to fit into fixed string of this size");
                this.Length = len;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator ==(in FixedString4096 a, in FixedString128 b)
        {
            // this must not call any methods on 'a' or 'b'
            unsafe {
                int alen = a.utf8LengthInBytes;
                int blen = b.utf8LengthInBytes;
                byte* aptr = (byte*) UnsafeUtilityExtensions.AddressOf(a.bytes);
                byte* bptr = (byte*) UnsafeUtilityExtensions.AddressOf(b.bytes);
                return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aptr, alen, bptr, blen);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator !=(in FixedString4096 a, in FixedString128 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(FixedString128 other)
        {
            return this == other;
        }

        /// <summary>
        /// Compare this FixedString4096 with a FixedString512 in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The FixedString to compare with</param>
        /// <returns>
        /// -1 if this FixedString4096 would appear first if sorted,
        ///  0 if they are identical, or
        ///  1 if the other FixedString512 would appear first if sorted.
        /// </returns>
        public int CompareTo(FixedString512 other)
        {
            return FixedStringMethods.CompareTo(ref this, other);
        }

        /// <summary>
        /// Construct a FixedString4096 by copying from another FixedString source.
        /// </summary>
        /// <param name="source"></param>
        public FixedString4096(in FixedString512 source)
        {
            bytes = default;
            utf8LengthInBytes = 0;
            unsafe {
                int len = 0;
                byte* dstBytes = GetUnsafePtr();
                byte* srcBytes = (byte*) UnsafeUtilityExtensions.AddressOf(source.bytes);
                var srcLength = source.utf8LengthInBytes;
                if (UTF8ArrayUnsafeUtility.AppendUTF8Bytes(dstBytes, ref len, utf8MaxLengthInBytes, srcBytes, srcLength) != FormatError.None)
                    throw new ArgumentException("Source is too long to fit into fixed string of this size");
                this.Length = len;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator ==(in FixedString4096 a, in FixedString512 b)
        {
            // this must not call any methods on 'a' or 'b'
            unsafe {
                int alen = a.utf8LengthInBytes;
                int blen = b.utf8LengthInBytes;
                byte* aptr = (byte*) UnsafeUtilityExtensions.AddressOf(a.bytes);
                byte* bptr = (byte*) UnsafeUtilityExtensions.AddressOf(b.bytes);
                return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aptr, alen, bptr, blen);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator !=(in FixedString4096 a, in FixedString512 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(FixedString512 other)
        {
            return this == other;
        }

        /// <summary>
        /// Compare this FixedString4096 with a FixedString4096 in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The FixedString to compare with</param>
        /// <returns>
        /// -1 if this FixedString4096 would appear first if sorted,
        ///  0 if they are identical, or
        ///  1 if the other FixedString4096 would appear first if sorted.
        /// </returns>
        public int CompareTo(FixedString4096 other)
        {
            return FixedStringMethods.CompareTo(ref this, other);
        }

        /// <summary>
        /// Construct a FixedString4096 by copying from another FixedString source.
        /// </summary>
        /// <param name="source"></param>
        public FixedString4096(in FixedString4096 source)
        {
            bytes = default;
            utf8LengthInBytes = 0;
            unsafe {
                int len = 0;
                byte* dstBytes = GetUnsafePtr();
                byte* srcBytes = (byte*) UnsafeUtilityExtensions.AddressOf(source.bytes);
                var srcLength = source.utf8LengthInBytes;
                if (UTF8ArrayUnsafeUtility.AppendUTF8Bytes(dstBytes, ref len, utf8MaxLengthInBytes, srcBytes, srcLength) != FormatError.None)
                    throw new ArgumentException("Source is too long to fit into fixed string of this size");
                this.Length = len;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator ==(in FixedString4096 a, in FixedString4096 b)
        {
            // this must not call any methods on 'a' or 'b'
            unsafe {
                int alen = a.utf8LengthInBytes;
                int blen = b.utf8LengthInBytes;
                byte* aptr = (byte*) UnsafeUtilityExtensions.AddressOf(a.bytes);
                byte* bptr = (byte*) UnsafeUtilityExtensions.AddressOf(b.bytes);
                return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aptr, alen, bptr, blen);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator !=(in FixedString4096 a, in FixedString4096 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(FixedString4096 other)
        {
            return this == other;
        }

        /// <summary>
        /// Enable implicit conversion of System.String to FixedString4096.
        /// </summary>
        /// <param name="b">The System.String object to convert to a FixedString4096</param>
        /// <returns></returns>
        public static implicit operator FixedString4096(string b) => new FixedString4096(b);

        /// <summary>
        /// Convert this FixedString4096 to a System.String.
        /// </summary>
        /// <returns>A System.String with a copy of this FixedString4096</returns>
        public override String ToString()
        {
            return this.ConvertToString();
        }

        /// <summary>
        /// Compute a hash code of this FixedString4096: an integer that is likely to be different for
        /// two FixedString4096, if their contents are different.
        /// </summary>
        /// <returns>A hash code of this FixedString4096</returns>
        public override int GetHashCode()
        {
            return this.ComputeHashCode();
        }

        /// <summary>
        /// Determines whether a FixedString4096 has the same value as some other object.
        /// </summary>
        /// <param name="obj">The object to compare for equality</param>
        /// <returns></returns>
        public override bool Equals(object obj)
        {
            if(ReferenceEquals(null, obj)) return false;
            if(obj is String aString) return Equals(aString);
            if(obj is FixedString32 aFixedString32) return Equals(aFixedString32);
            if(obj is FixedString64 aFixedString64) return Equals(aFixedString64);
            if(obj is FixedString128 aFixedString128) return Equals(aFixedString128);
            if(obj is FixedString512 aFixedString512) return Equals(aFixedString512);
            if(obj is FixedString4096 aFixedString4096) return Equals(aFixedString4096);
            return false;
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        void CheckIndexInRange(int index)
        {
            if (index < 0)
                throw new IndexOutOfRangeException($"Index {index} must be positive.");
            if (index >= utf8LengthInBytes)
                throw new IndexOutOfRangeException($"Index {index} is out of range in FixedString4096 of '{utf8LengthInBytes}' Length.");
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        void CheckLengthInRange(int length)
        {
            if (length < 0)
                throw new ArgumentOutOfRangeException($"Length {length} must be positive.");
            if (length > utf8MaxLengthInBytes)
                throw new ArgumentOutOfRangeException($"Length {length} is out of range in FixedString4096 of '{utf8MaxLengthInBytes}' Capacity.");
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        void CheckCapacityInRange(int capacity)
        {
            if (capacity != Capacity)
                throw new ArgumentOutOfRangeException($"Capacity {capacity} must be {Capacity}.");
        }
    }
}
