
<#/*THIS IS A T4 FILE - see t4_text_templating.md for what it is and how to run codegen*/#>
<#@ template debug="True" #>
<#@ output extension=".gen.cs" encoding="utf-8" #>
<#@ assembly name="System.Core" #>

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     TextTransform Samples/Packages/com.unity.collections/Unity.Collections/FixedString.tt
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System.Collections.Generic;
using System.Collections;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Mathematics;
using UnityEngine.Internal;
using UnityEngine;
#if UNITY_PROPERTIES_EXISTS
using Unity.Properties;
#endif

namespace Unity.Collections
{

    // A temporary copy of a struct is made before it is displayed in a C# debugger.
    // However, only the first element of data members with names is copied at this time.
    // Therefore, it's important that all data visible in the debugger, has a name
    // and includes no 'fixed' array. This is why we name every byte in the following struct.

    [Serializable]
    [StructLayout(LayoutKind.Explicit, Size=16)]
    [BurstCompatible]
    public struct FixedBytes16
    {
<#
    for(var i = 0; i < 16; ++i)
    {
       var offset = i.ToString("D4");
#>
      [FieldOffset(<#=i#>)] public byte byte<#=offset#>;
<#
    }
#>
    }

<#
{
    var SIZES = new [] {32,64,128,512,4096};
    foreach (var BYTES in SIZES) {
        // 2 bytes for the ushort length
      var MAXLENGTH = BYTES - 2;
#>

    // A temporary copy of a struct is made before it is displayed in a C# debugger.
    // However, only the first element of data members with names is copied at this time.
    // Therefore, it's important that all data visible in the debugger, has a name
    // and includes no 'fixed' array. This is why we name every byte in the following struct.

    [Serializable]
    [StructLayout(LayoutKind.Explicit, Size=<#=MAXLENGTH#>)]
    [BurstCompatible]
    public struct FixedBytes<#=MAXLENGTH#>
    {
<#
      for(var i = 0; i < (MAXLENGTH/16)*16; i += 16)
      {
        var offset = i.ToString("D4");
#>
        [FieldOffset(<#=i#>)] public FixedBytes16 offset<#=offset#>;
<#
      }
      for(var i = (MAXLENGTH/16)*16; i < MAXLENGTH; ++i)
      {
        var offset = i.ToString("D4");
#>
        [FieldOffset(<#=i#>)] public byte byte<#=offset#>;
<#
      }
#>
    }

    /// <summary>
    /// An unmanaged string in UTF-8 format that contains its own fixed-size buffer of the given size in bytes.
    /// The string is guaranteed to be null-terminated, at the byte at the current Length offset.
    /// No memory is ever allocated, and no attempt is made to share memory when strings are copied.
    /// Since this structure is not generic and needs no disposing, it can exist inside ECS components,
    /// can be put in a FixedArray, FixedList or FixedHashMap, and can be a data member of unmanaged structs
    /// that are allocated from the unmanaged heap. This string is entirely compatible with Burst compilation.
    ///
    /// The binary layout of this string is guaranteed, for now and all time, to be two bytes of little-endian length,
    /// followed by a contiguous array of bytes with that length, with no padding in between. This is intentionally
    /// identical to FixedList of byte, which is guaranteed to always have the same memory layout.
    ///
    /// Those who need more than 65,535 contiguous items should allocate from the heap, as storing that many things
    /// contiguously in a C# struct is likely to result in much wasted time, as the compiler copies the struct often.
    /// </summary>
    [Serializable]
    [StructLayout(LayoutKind.Sequential, Size=<#=BYTES#>)]
    [BurstCompatible]
    public partial struct FixedString<#=BYTES#>
        : INativeList<byte>
        , IUTF8Bytes
        , IComparable<String>
        , IEquatable<String>
<#
      foreach (var OTHERBYTES in SIZES)
      {
#>
        , IComparable<FixedString<#=OTHERBYTES#>>
        , IEquatable<FixedString<#=OTHERBYTES#>>
<#
      }
#>
    {
        internal const ushort utf8MaxLengthInBytes = <#=MAXLENGTH-1#>;

        [SerializeField] internal ushort utf8LengthInBytes;
        [SerializeField] internal FixedBytes<#=MAXLENGTH#> bytes;

        /// <summary>
        /// Returns the maximum number of utf8 bytes that can be stored in this type.
        /// </summary>
        public static int UTF8MaxLengthInBytes => utf8MaxLengthInBytes;

        /// <summary>
        /// A property in order to display the value in Unity.Properties generated UI.
        /// </summary>
        [CreateProperty]
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        [NotBurstCompatible]
        public string Value => ToString();

        /// <summary>
        ///
        /// </summary>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe byte* GetUnsafePtr()
        {
            return (byte*) UnsafeUtility.AddressOf(ref bytes);
        }

        //
        // INativeList<byte> methods
        //

        /// <summary>
        /// The current length of the UTF-8 encoded string, in bytes. The string is guaranteed to be
        /// null-terminated. The length value does not include the null terminating byte. It is valid to
        /// read the null byte at the Length position when accessing this data by raw pointer.
        /// </summary>
        public int Length
        {
            get
            {
                return utf8LengthInBytes;
            }
            set
            {
                CheckLengthInRange(value);
                utf8LengthInBytes = (ushort)value;
                unsafe
                {
                    GetUnsafePtr()[utf8LengthInBytes] = 0;
                }
            }
        }

        /// <summary>
        /// The maximum available capacity of the UTF-8 encoded string, in bytes.
        /// Due to the UTF-8 encoding, each Unicode code point requires between 1 and 4 bytes to encode.
        /// The null terminating byte is not included in the capacity.  The FixedString always
        /// has space for a null terminating byte.  For FixedString<#=BYTES#>, attempting to set this value
        /// to anything lower than <#=BYTES-3#> will throw.  The Capacity will always be <#=BYTES-3#>.
        /// </summary>
        public int Capacity
        {
            get
            {
                return utf8MaxLengthInBytes;
            }
            set
            {
                CheckCapacityInRange(value);
            }
        }

        /// <summary>
        /// Attempt to set the length of the string, in UTF-8 bytes.
        /// </summary>
        /// <param name="newLength">The new length of the string</param>
        /// <param name="clearOptions">Whether the new memory should be initialized or not</param>
        /// <returns>Whether the resize was successful.</returns>
        public bool TryResize(int newLength, NativeArrayOptions clearOptions = NativeArrayOptions.ClearMemory)
        {
            if (newLength < 0 || newLength > utf8MaxLengthInBytes)
                return false;
            if (newLength == utf8LengthInBytes)
                return true;
            unsafe
            {
                if (clearOptions == NativeArrayOptions.ClearMemory)
                {
                    if (newLength > utf8LengthInBytes)
                        UnsafeUtility.MemClear(GetUnsafePtr() + utf8LengthInBytes, newLength - utf8LengthInBytes);
                    else
                        UnsafeUtility.MemClear(GetUnsafePtr() + newLength, utf8LengthInBytes - newLength);
                }
                utf8LengthInBytes = (ushort)newLength;
                // always null terminate
                GetUnsafePtr()[utf8LengthInBytes] = 0;
            }
            return true;
        }

        /// <summary>
        /// Reports whether container is empty.
        /// </summary>
        /// <value>True if this container empty.</value>
        public bool IsEmpty => utf8LengthInBytes == 0;

        /// <summary>
        /// Return the byte at the given byte (not character) index.  The index
        /// must be in the range of [0..Length)
        /// </summary>
        public byte this[int index]
        {
            get
            {
                unsafe
                {
                    CheckIndexInRange(index);
                    return GetUnsafePtr()[index];
                }
            }

            set
            {
                unsafe
                {
                    CheckIndexInRange(index);
                    GetUnsafePtr()[index] = value;
                }
            }
        }

        /// <summary>
        /// Return a ref to the the byte at the given byte (not character) index.  The index
        /// must be in the range of [0..Length).  The ref byte is a direct reference into
        /// this FixedString, and is only valid while this FixedString is valid.
        /// </summary>
        /// <param name="index">The byte index to access</param>
        /// <returns>A ref byte for the requested index</returns>
        public ref byte ElementAt(int index)
        {
            unsafe
            {
                CheckIndexInRange(index);
                return ref GetUnsafePtr()[index];
            }
        }

        /// <summary>
        /// Clear this string by setting its Length to 0.
        /// </summary>
        public void Clear()
        {
            Length = 0;
        }

        /// <summary>
        /// Append the given byte value to this string. The string will remain null-terminated after the new
        /// byte. Appending an invalid UTF-8 sequence will cause the contents of this string to be invalid when
        /// converted to UTF-16 or UCS-2. No validation of the appended bytes is done.
        /// </summary>
        /// <param name="value">The byte to append.</param>
        public void Add(in byte value)
        {
            this[Length++] = value;
        }

        /// <summary>
        /// <undoc />
        /// </summary>
        public struct Enumerator : IEnumerator
        {
            FixedString<#=BYTES#> target;
            int offset;
            Unicode.Rune current;

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <param name="other"><undoc /></param>
            public Enumerator(FixedString<#=BYTES#> other)
            {
                target = other;
                offset = 0;
                current = default;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Dispose()
            {
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <returns><undoc /></returns>
            public bool MoveNext()
            {
                if (offset >= target.Length)
                    return false;

                unsafe
                {
                    Unicode.Utf8ToUcs(out current, target.GetUnsafePtr(), ref offset, target.Length);
                }

                return true;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Reset()
            {
                offset = 0;
                current = default;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public Unicode.Rune Current => current;

            object IEnumerator.Current => Current;
        }

        /// <summary>
        /// Returns an enumerator that iterates through a container.
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the container.</returns>
        public Enumerator GetEnumerator()
        {
            return new Enumerator(this);
        }

        /// <summary>
        /// Compare this FixedString<#=BYTES#> with a System.String in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The System.String to compare with</param>
        /// <returns>
        /// -1 if this FixedString<#=BYTES#> would appear first if sorted,
        ///  0 if they are identical, or
        ///  1 if the other System.String would appear first if sorted.
        /// </returns>
        [NotBurstCompatible]
        public int CompareTo(String other)
        {
            return ToString().CompareTo(other);
        }

        /// <summary>
        /// Compare this FixedString<#=BYTES#> with a System.String,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The System.String to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        [NotBurstCompatible]
        public bool Equals(String other)
        {
            return ToString().Equals(other);
        }

        /// <summary>
        /// Transform this struct to a reference to a FixedListByteN, which has the same layout.
        /// The returned reference is a reference to this data, and is only valid while it is valid.
        /// </summary>
        /// <returns></returns>
        public unsafe ref FixedListByte<#=BYTES#> AsFixedList()
        {
            return ref UnsafeUtility.AsRef<FixedListByte<#=BYTES#>>(UnsafeUtility.AddressOf(ref this));
        }

        /// <summary>
        /// Construct a FixedString<#=BYTES#> from a System.String object.
        /// </summary>
        /// <param name="source">The System.String object to construct this FixedString<#=BYTES#> with</param>
        public FixedString<#=BYTES#>(String source)
        {
            bytes = default;
            utf8LengthInBytes = 0;
            unsafe
            {
                fixed (char* sourceptr = source)
                {
                    var error = UTF8ArrayUnsafeUtility.Copy(GetUnsafePtr(), out utf8LengthInBytes, utf8MaxLengthInBytes, sourceptr, source.Length);
                    CheckCopyError(error, source);
                    this.Length = utf8LengthInBytes;
                }
            }
        }

        /// <summary>
        /// Construct a FixedString<#=BYTES#> by repeating the given Unicode.Rune a number of times.
        /// </summary>
        /// <param name="rune">The Unicode.Rune to repeat</param>
        /// <param name="count">The number of times to repeat, default 1</param>
        public FixedString<#=BYTES#>(Unicode.Rune rune, int count = 1)
        {
            bytes = default;
            utf8LengthInBytes = 0;
            this.Append(rune, count);
        }

<#
    //
    // Generate easy conversion and comparison between this and other FixedString types
    //
    foreach (var OTHERBYTES in SIZES)
    {
#>
        /// <summary>
        /// Compare this FixedString<#=BYTES#> with a FixedString<#=OTHERBYTES#> in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The FixedString to compare with</param>
        /// <returns>
        /// -1 if this FixedString<#=BYTES#> would appear first if sorted,
        ///  0 if they are identical, or
        ///  1 if the other FixedString<#=OTHERBYTES#> would appear first if sorted.
        /// </returns>
        public int CompareTo(FixedString<#=OTHERBYTES#> other)
        {
            return FixedStringMethods.CompareTo(ref this, other);
        }

        /// <summary>
        /// Construct a FixedString<#=BYTES#> by copying from another FixedString source.
        /// </summary>
        /// <param name="source"></param>
        public FixedString<#=BYTES#>(in FixedString<#=OTHERBYTES#> source)
        {
            bytes = default;
            utf8LengthInBytes = 0;
            unsafe {
                int len = 0;
                byte* dstBytes = GetUnsafePtr();
                byte* srcBytes = (byte*) UnsafeUtilityExtensions.AddressOf(source.bytes);
                var srcLength = source.utf8LengthInBytes;
                var error = UTF8ArrayUnsafeUtility.AppendUTF8Bytes(dstBytes, ref len, utf8MaxLengthInBytes, srcBytes, srcLength);
                CheckFormatError(error);
                this.Length = len;
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator ==(in FixedString<#=BYTES#> a, in FixedString<#=OTHERBYTES#> b)
        {
            // this must not call any methods on 'a' or 'b'
            unsafe {
                int alen = a.utf8LengthInBytes;
                int blen = b.utf8LengthInBytes;
                byte* aptr = (byte*) UnsafeUtilityExtensions.AddressOf(a.bytes);
                byte* bptr = (byte*) UnsafeUtilityExtensions.AddressOf(b.bytes);
                return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aptr, alen, bptr, blen);
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator !=(in FixedString<#=BYTES#> a, in FixedString<#=OTHERBYTES#> b)
        {
            return !(a == b);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(FixedString<#=OTHERBYTES#> other)
        {
            return this == other;
        }

<#
        if (OTHERBYTES > BYTES)
        {
            // Generate implicit conversions to bigger-sized FixedStrings
#>
        /// <summary>
        ///
        /// </summary>
        /// <param name="fs"></param>
        /// <returns></returns>
        public static implicit operator FixedString<#=OTHERBYTES#>(in FixedString<#=BYTES#> fs) => new FixedString<#=OTHERBYTES#>(in fs);

<#
        }
    }
#>
        /// <summary>
        /// Enable implicit conversion of System.String to FixedString<#=BYTES#>.
        /// </summary>
        /// <param name="b">The System.String object to convert to a FixedString<#=BYTES#></param>
        /// <returns></returns>
        [NotBurstCompatible]
        public static implicit operator FixedString<#=BYTES#>(string b) => new FixedString<#=BYTES#>(b);

        /// <summary>
        /// Convert this FixedString<#=BYTES#> to a System.String.
        /// </summary>
        /// <returns>A System.String with a copy of this FixedString<#=BYTES#></returns>
        [NotBurstCompatible]
        public override String ToString()
        {
            return this.ConvertToString();
        }

        /// <summary>
        /// Compute a hash code of this FixedString<#=BYTES#>: an integer that is likely to be different for
        /// two FixedString<#=BYTES#>, if their contents are different.
        /// </summary>
        /// <returns>A hash code of this FixedString<#=BYTES#></returns>
        public override int GetHashCode()
        {
            return this.ComputeHashCode();
        }

        /// <summary>
        /// Determines whether a FixedString<#=BYTES#> has the same value as some other object.
        /// </summary>
        /// <param name="obj">The object to compare for equality</param>
        /// <returns></returns>
        [NotBurstCompatible]
        public override bool Equals(object obj)
        {
            if(ReferenceEquals(null, obj)) return false;
            if(obj is String aString) return Equals(aString);
<#
    foreach(var OTHERBYTES in SIZES)
    {
        var OTHERTYPENAME = "FixedString" + OTHERBYTES;
        WriteLine("            if(obj is {0} a{0}) return Equals(a{0});", OTHERTYPENAME);
    }
#>
            return false;
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        void CheckIndexInRange(int index)
        {
            if (index < 0)
                throw new IndexOutOfRangeException($"Index {index} must be positive.");
            if (index >= utf8LengthInBytes)
                throw new IndexOutOfRangeException($"Index {index} is out of range in FixedString<#=BYTES#> of '{utf8LengthInBytes}' Length.");
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        void CheckLengthInRange(int length)
        {
            if (length < 0)
                throw new ArgumentOutOfRangeException($"Length {length} must be positive.");
            if (length > utf8MaxLengthInBytes)
                throw new ArgumentOutOfRangeException($"Length {length} is out of range in FixedString<#=BYTES#> of '{utf8MaxLengthInBytes}' Capacity.");
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        void CheckCapacityInRange(int capacity)
        {
            if (capacity > utf8MaxLengthInBytes)
                throw new ArgumentOutOfRangeException($"Capacity {capacity} must be lower than {utf8MaxLengthInBytes}.");
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        static void CheckCopyError(CopyError error, String source)
        {
            if (error != CopyError.None)
                throw new ArgumentException($"FixedString32: {error} while copying \"{source}\"");
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        static void CheckFormatError(FormatError error)
        {
            if (error != FormatError.None)
                throw new ArgumentException("Source is too long to fit into fixed string of this size");
        }
    }
<#}}#>
}
